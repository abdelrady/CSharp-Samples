using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using Helpers;

namespace PS3
{
    public class Solution2
    {
        static void Main1(string[] args)
        {
            //var sln = new Solution1();

            //sln.Trap(new[] { 0, 1, 0, 3, 1, 0, 1, 3, 2, 1, 2, 1 }).Print();

            //sln.LargestRectangleArea(new[] { 1, 2, 3, 4 }).Print();

            //var wordDictionary = new TrieNear.WordDictionary();
            //wordDictionary.AddWord("bad");
            ////wordDictionary.Search("b..").Print();
            //wordDictionary.AddWord("at");
            //wordDictionary.AddWord("and");
            //wordDictionary.AddWord("an");
            //wordDictionary.AddWord("add");
            //wordDictionary.Search("a").Print(); // return False
            //wordDictionary.Search(".at").Print(); // return True
            //wordDictionary.AddWord("bat");
            //wordDictionary.Search(".at").Print(); // return True
            //wordDictionary.Search("an.").Print(); // return True
            //wordDictionary.Search("a.d.").Print(); // return True
            //wordDictionary.Search("b.").Print(); // return True
            //wordDictionary.Search("a.d").Print(); // return True
            //wordDictionary.Search(".").Print(); // return True

            //sln.ExclusiveTime(2,
            //    new List<string> { "0:start:0", "1:start:2", "1:end:5", "0:end:6" }).Print();
            //sln.ExclusiveTime(1,
            //    new List<string> { "0:start:0", "0:start:2", "0:end:5", "0:start:6", "0:end:6", "0:end:7" }).Print();
            //sln.ExclusiveTime(2,
            //    new List<string> { "0:start:0", "0:start:2", "0:end:5", "1:start:6", "1:end:6", "0:end:7" }).Print();
            //sln.ExclusiveTime(2,
            //    new List<string> { "0:start:0", "0:start:2", "0:end:5", "1:start:7", "1:end:7", "0:end:8" }).Print();
            //sln.ExclusiveTime(1,
            //    new List<string> { "0:start:0", "0:end:0" }).Print();

            //sln.ExclusiveTime(1,
            //    new List<string> { "0:start:0", "0:start:1", "0:start:2", "0:end:3", "0:end:4", "0:end:5" }).Print();

            //sln.RemoveDuplicates("abcd", 3).Print();
            //sln.RemoveDuplicates("deeedbbcccbdaa", 3).Print();
            //sln.RemoveDuplicates("pbbcggttciiippooaais", 2).Print();

            //sln.BestTeamScore_Topdown(new[] { 1, 3, 7, 3, 2, 4, 10, 7, 5 }, new[] { 4, 5, 2, 1, 1, 2, 4, 1, 4 }).Print();

            //sln.AreConnected(6,
            //    2,
            //    new[]
            //    {
            //        new[] {1, 4},
            //        new[] {2, 5},
            //        new[] {3, 6},
            //    }).Print();

            //sln.Rotate("1234567", 3).ToString().Print();

            //sln.FindLexSmallestString("5525", 9, 2).Print();

            //sln.RemoveKdigits("10", 2).Print();

            //sln.MonotonicStack();

            //sln.Calculate("(2+6* 3+5- (3*14/7+2)*5)+3").Print();

            //sln.LargestNumber(new[] {3, 30, 34, 5, 9}).Print();

            //sln.LongestSubarray1(new[] { 8, 2, 4, 7 }, 4).Print();

            //sln.ShortestSubarray(new[] { 84, -37, 1, 32, 40, 170 }, 167).Print();

            //sln.LongestOnes(new[] { 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1 }, 3).Print();

            //sln.SubarraysWithKDistinct(new[] { 1, 2, 1, 2, 3 }, 2).Print();

            //sln.MinWindow("abcdebdde", "bde").Print();

            //sln.LongestWord(new []{ "w", "wo", "wor", "worl", "world" }).Print();

            //sln.GetDivisors(99).Print();

            //sln.Shuffle(new[] { 0, 1, 2, 3, 4, 5, 6, 7 }, 4).Print();

            //sln.MergeTrees(new int?[] {1, 3, 2, 5}.BuildTreeFromArray(),
            //    new int?[] {2, 1, 3, null, 4, null, 7}.BuildTreeFromArray());

            //sln.ReachingPoints(1,
            //11,
            //999999991,
            //11).Print();

            //sln.MaxProfit(new[] { 8, 6, 4, 3, 3, 2, 3, 5, 8, 3, 8, 2, 6 }).Print();

            //sln.StrongPasswordChecker("aaa111").Print();

            //sln.MaxProfit(new[] { 1, 2, 4 }).Print();

            //sln.RepeatedSubstringPattern("abaababaab").Print();

            //sln.FurthestBuilding(new[] { 4, 2, 7, 6, 9, 14, 12 }, 5, 1).Print();
            //sln.FurthestBuilding(new[] { 4, 12, 2, 7, 3, 18, 20, 3, 19 }, 10, 2).Print();
            //sln.FurthestBuilding(new[] { 14, 3, 19, 3 }, 17, 0).Print();

            //sln.CanFormArray(new []{91, 4, 64, 78}, new []
            //{
            //    new []{78},
            //    new []{4, 64},
            //    new []{91},
            //}).Print();

            //sln.Multiply("123",
            //"456").Print();

            //sln.LadderLength("hit", "cog", new List<string> { "hot", "dot", "dog", "lot", "log", "cog" }).Print();

            //sln.ScheduleCourse(new []
            //{
            //    new []{100, 200},
            //    new []{200, 1300},
            //    new []{1000, 1250},
            //    new []{2000, 3200},
            //}).Print();

            //sln.GetMaximumGenerated(2).Print();

            //sln.MinDeletions("abcabc").Print();

            //sln.LongestIncreasingPath(new[]
            //{
            //    new []{1, 2},
            //}).Print();

            //sln.DecodeString("3[a]2[bc]").Print();

            //var tree = new int?[] { 1, 2, 3, 4, 5 }.BuildTreeFromArray();
            //sln.DiameterOfBinaryTree(tree).Print();

            //sln.Insert(new int[][]
            //{
            //    new []{ 1,3 },
            //    new []{ 6,9 },
            //    //new []{ 6,7 },
            //    //new []{ 8,10 },
            //    //new []{ 12,16 },
            //}
            //, new[] { 2, 5 }).Print();

            //sln.MaxProduct(new[] { 2, -3, -1, 0 }).Print();

            //var tree = new[] {7, 3, 15, (int?) null, null, 9, 20}.BuildTreeFromArray();
            //var iterator = new Solution.BSTIterator(tree);
            //iterator.Next().Print();
            //iterator.Next().Print();
            //iterator.Prev().Print();
            //iterator.Next().Print();
            //iterator.HasNext().Print();
            //iterator.Next().Print();
            //iterator.Next().Print();
            //iterator.Next().Print();
            //iterator.HasNext().Print();
            //iterator.HasPrev().Print();
            //iterator.Prev().Print();
            //iterator.Prev().Print();

            //sln.IsStrobogrammatic("2").Print();

            //sln.IsIsomorphic("ab", "ba").Print();

            //sln.CloseStrings("abc", "cba").Print();

            //sln.MinOperations(new[] { 3, 2, 20, 1, 1, 3 }, 10).Print();

            //sln.LengthOfLongestSubstringTwoDistinct("ccaabbb").Print();

            //sln.FindKthLargest(new []{ 3, 2, 1, 5, 6, 4 }, 7).Print();

            //var segTree = new Solution.NumArray(new[] { -2, 0, 3, -5, 2, -1 });
            //segTree.SumRange(0, 2).Print();
            //segTree.SumRange(2, 5).Print();
            ////segTree.Update(1, 2);
            //segTree.SumRange(0, 5).Print();

            //sln.NumDistinctIslands(new[]
            //{
            //    new[] {1, 1, 0, 0, 0},
            //    new[] {1, 1, 0, 0, 0},
            //    new[] {0, 0, 0, 1, 1},
            //    new[] {0, 0, 0, 1, 1},
            //}).Print();

            //sln.SumSubarrayMins(new int[] {3, 1, 2, 4}).Print();

            var sln = new Solution2();

            //sln.NextGreaterElement(new[] { 4, 1, 2 }, new[] { 1, 3, 4, 2 }).Print();

            //sln.SumSubarrayMins(new[] { 3, 1, 2, 4 }).Print();

            //sln.Permute(new[] { 1, 2, 3, 4 }).Print();

            //var arr = new[] { 3, 4, 2, 1 };
            //sln.NextPermutation(arr);
            //arr.Print();//4 2 3 1

            //var sgt = new Solution.NumMatrix(new []
            //{
            //    new []{3,0,1,4,2},
            //    new []{5,6,3,2,1},
            //    new []{1,2,0,1,5},
            //    new []{4,1,0,1,7},
            //    new []{1,0,3,0,5},
            //});

            //sgt.SumRegion(2, 1, 4, 3).Print();
            //sgt.Update(3, 2, 2);
            //sgt.SumRegion(2, 1, 4, 3).Print();


            //var btree = new int?[] { 1, 2, 5, 3, 4, (int?)null, 6 }.BuildTreeFromArray();
            //sln.Flatten(btree);

            //var btree = new int?[] { 1, -2, 3 }.BuildTreeFromArray();
            //sln.MaxPathSum(btree).Print();

            //sln.NumIslands(new[]
            //{
            //    new []{ '1', '0', '1', '1', '0', '1', '1' }
            //}).Print();

            //var bTree = new int?[] {1, 2, 3, 4, 5, 6}.BuildTreeFromArray();
            //sln.LowestCommonAncestor(bTree, new TreeNode(5), new TreeNode(7)).Print();

            //sln.BinaryTreePaths(bTree).Print();

            //sln.NextGreaterElement(1999999999).Print();

            //sln.ShortestDistance(new []
            //{
            //    new []{1,0,2,0,1},
            //    new []{0,0,0,0,0},
            //    new []{0,0,1,0,0},
            //}).Print();

            //sln.RemoveDuplicates(new []{0,0,1,1,1,2}).Print();

            //sln.GroupAnagrams(new[] { "bat", "rat", "art" }).Print();

            //sln.AddBinary("1010", "1011").Print();

            //sln.CheckInclusion("ab", "eidbaooo").Print();

            //sln.FindAnagrams("cbaebabacd", "abc").Print();

            //sln.PermuteUnique(new[] { 1, 1, 2 }).Print();

            //sln.RemoveInvalidParentheses("()())()").Print();

            //sln.Subsets(new[] { 1, 2, 3 }).Print();

            //[1,2,3,4]
            //var _1 = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));
            //sln.ReorderList(_1);
            //_1.Print();

            //sln.ReverseList(_1).Print();
            //sln.ReverseBetween(_1, 2, 4).Print();

            //sln.ReorderList(_1);
            //_1.Print();


            //sln.LongestValidParentheses("()(())").Print();

            //sln.GetSmallestString(5, 73).Print();

            //sln.WaysToMakeFair(new[] { 1,2,3 }).Print();

            //sln.MinimumEffort(new []
            //{
            //    new []{1,1},
            //    new []{1,3},
            //}).Print();

            //sln.SubarraySum(new[] { 3, 4, 7, 2, -3, 1, 4, 2 }, 7).Print();

            //sln.LetterCombinations("23").Print();

            //var mat = new Solution.NumMatrix1(new []
            //{
            //    new []{3, 0, 1, 4, 2},
            //    new []{5, 6, 3, 2, 1},
            //    new []{1, 2, 0, 1, 5},
            //    new []{4, 1, 0, 1, 7},
            //    new []{1, 0, 3, 0, 5},
            //});
            //mat.SumRegion(2,1,4,3).Print();

            //sln.FindPeakElement(new []{0,1,2,3,2,1,0}).Print();

            //sln.PeakIndexInMountainArray(new[] { 3, 4, 5, 1 }).Print();

            //sln.FindInMountainArray(3, new Solution.MountainArray(new[] { 0, 1, 2, 4, 5, 3, 1})).Print();


            //sln.AccountsMerge(new List<IList<string>>
            //{
            //    new List<string>
            //    {
            //        "John","johnsmith@mail.com","john_newyork@mail.com"
            //    },
            //    new List<string>
            //    {
            //        "John","johnsmith@mail.com","john00@mail.com"
            //    },
            //    new List<string>
            //    {
            //        "Mary","mary@mail.com"
            //    },
            //    new List<string>
            //    {
            //        "John","johnnybravo@mail.com"
            //    },
            //}).Print();


            //sln.ValidIPAddress("2001:0db8:85a3:0:0:8A2E:0370:7334:").Print();

            //sln.NumPairsDivisibleBy60(new []{60,60,60}).Print();

            //sln.Search(new[] { 3, 1 }, 1).Print();

            //var vc = new Solution.Solution5();
            //vc.FirstBadVersion(5).Print();
            //vc.count.Print();

            //sln.Intersect(new[] { 1, 2 }, new[] { 1, 1 }).Print();

            //sln.Divide(93706, 157).Print();

            //sln.MyPow(3, 4).Print();

            //sln.MySqrt(9).Print();

            //sln.WordBreak_DP("catsanddog", new List<string>
            //{
            //    "cats", "dog", "sand", "and", "cat"
            //}).Print();

            //var tree = new int?[] {1, 2, 3, null, null, 4, 5}.BuildTreeFromArray();
            //var codec = new Solution.Codec();
            //var ser = codec.serialize(tree);
            //var ser1 = codec.serialize1(tree);
            //(ser == ser1).Print();
            //ser.Print();
            //var newTree = codec.deserialize(ser);

            //var bstIterator = new Solution.BSTIterator(new int?[]{ 7, 3, 15, null, null, 9, 20 }.BuildTreeFromArray());
            //bstIterator.Next().Print();
            //bstIterator.Next().Print();
            //bstIterator.Next().Print();

            //var lru = new Solution.LRUCache(2);
            //lru.Put(2, 1);
            //lru.Put(1, 1);
            //lru.Put(2, 3);
            //lru.Put(4, 1);
            //lru.Get(1).Print();
            //lru.Get(2).Print();

            //sln.countSubarrays(new[] { 3, 4, 1, 6, 2 }).Print();

            //var _3 = new Node(3);
            //var _1 = new Node(1);
            //var _5 = new Node(5);
            //var _2 = new Node(2, _1, _3);
            //var _4 = new Node(4, _2, _5);
            //var dlist = sln.TreeToDoublyList(_4);

            //sln.NumDecodings("2101").Print();

            //sln.CheckSubarraySum(new[] { 23, 2, 4, 6, 7 }, 6).Print();
            //sln.CheckSubarraySum(new[] { 1, 2, 6, 4, 7 }, 6).Print();
            //sln.CheckSubarraySum(new[] { 23, 2, 6, 3 }, 6).Print();
            //sln.CheckSubarraySum(new[] { 0, 0 }, 0).Print();

            //sln.NumberToWords(10).Print();

            //sln.IsBipartite(new []
            //{
            //    //[[4],[],[4],[4],[0,2,3]]
            //    new int[0],
            //    new []{ 4 },
            //    new []{4},
            //    new []{4},
            //    new []{0,2,3},
            //}).Print();

            //var tree = sln.BuildTree( new[] {9, 3, 15, 20, 7}, new []{ 9, 15, 7, 20, 3 });

            //sln.constructFromPrePost(new[] { 1, 2, 4, 5, 3, 6, 7 }, new[] { 4, 5, 2, 6, 7, 3, 1 });

            //sln.IsMatch("aab", "c*a*b").Print();

            //sln.MinWindow("a", "b").Print();

            //sln.SampleStats(new[] { 0, 1, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }).Print();

            //sln.LongestPalindrome("aaaa").Print();

            //sln.ThreeSumSmaller(new[] { 1, -1, 2, 0, 3, -2 }, 2).Print();

            //sln.FindKthLargest(new[] {3, 2, 1, 5, 6, 4}, 4).Print();

            //sln.MaxSubArrayLen(new []{1, -1, 5, -2, 3}, 3).Print();

            //sln.AddOperators("105", 5).Print();

            //sln.RomanToInt("MCMXCIV").Print();

            //sln.Divide(93706, 157).Print();

            //var grantsArray = new double[] { 2, 4 };
            //var capLocation = Array.BinarySearch(grantsArray, 100);
            //if (capLocation < 0)
            //{
            //    capLocation = ~capLocation;
            //}

            //sln.FindGrantsCap(grantsArray, 3d).Print();

            //sln.Trap(new[] { 4, 2, 0, 3, 2, 5 }).Print();

            //sln.findGrantsCap(new double[] { 2, 100, 50, 120, 1000 }, 190).Print();

            //sln.minOperations(new[] { 4, 1, 3, 2 }).Print();

            //sln.IsNumber("-1.").Print();

            //sln.MaximumSwap(9973).Print();


            //var tree = new int[] {2, 2, 5, 2, 3, 5, 7}.BuildTreeFromArray();
            //sln.FindSecondMinimumValue(tree).Print();

            //var tree = new int?[] { 4, 1, 6, null, null, 5, null, 2 }.BuildTreeFromArray();
            //sln.LargestBSTSubtree(tree).Print();

            //sln.Multiply(new int[][]
            //    {
            //        new int[]
            //        {
            //            1, 0, 0
            //        },
            //        new int[]
            //        {
            //            -1, 0, 3
            //        },
            //    },
            //    new int[][]
            //    {
            //        new int[]
            //        {
            //            7, 0, 0
            //        },
            //        new int[]
            //        {
            //            0, 0, 0
            //        },
            //        new int[]
            //        {
            //            0, 0, 1
            //        }
            //    }).Print();

            //sln.KthSmallest(new[]
            //{
            //    new[] {1,4,7,11,15},
            //    new[] {2,5,8,12,19},
            //    new[] {3,6,9,16,22},
            //    new[] {10,13,14,17,24},
            //    new[] {18,21,23,26,30},
            //}, 5).Print();

            //sln.CoinChange(new[] { 1, 2, 5 }, 5).Print();

            //var res = Solution.WordCountEngine("Practice makes perfect. you'll only get Perfect by practice. just practice!");
            //foreach (var re in res)
            //{
            //    re.Print();
            //}

            //sln.Change(5, new[] { 1, 2, 5 }).Print();

            //sln.CoinChange( new[] { 1, 2, 5 }, 11).Print();

            //sln.FindCircleNum(new[]
            //{
            //    new []{1,1,0},
            //    new []{1,1,0},
            //    new []{0,0,1},
            //}).Print();

            //sln.LongestConsecutive(new[] { 100, 4, 200, 1, 3, 2 }).Print();

            //sln.Change(7, new int[] { 1, 2, 5 });

            //sln.CoinChange(new[] { 1, 2, 5 }, 11).Print();

            //sln.LongestPalindromeSubseq("bbbab").Print();

            //sln.LongestPalindrome("cbbd").Print();

            //queries = [[2, 3], [1, 2], [2, 1], [2, 3], [2, 2]]
            //output = [-1, 2, -1, 2]

            //var seg = new Solution.SegTreeSample();
            //seg.countSmaller(new []{ 5, 2, 6, 1 }).Print();

            //sln.CountAndSay(4).Print();

        }

        public string CountAndSay(int n)
        {
            return CountAndSayRec(n);
        }

        private string CountAndSayRec(in int i)
        {
            if (i == 1)
                return "1";
            var next = CountAndSayRec(i - 1);

            var sb = new StringBuilder();
            int count = 1;

            for (int j = 0; j < next.Length - 1; j++)
            {
                if (next[j] == next[j + 1])
                    count++;
                else
                {
                    sb.Append(count.ToString() + next[j]);
                    count = 1;
                }
            }

            sb.Append(count.ToString() + next[next.Length - 1]);

            return sb.ToString();
        }

        public class SegTreeSample
        {
            class SegTreeNode
            {
                public int min, max; // range [min, max]
                public int count;
                public SegTreeNode left, right;

                public int mid()
                {
                    return ((max + 1 - min) / 2 + min);
                }

                public SegTreeNode(int min, int max)
                {
                    this.min = min;
                    this.max = max;
                    count = 0;
                }
            }

            public List<int> countSmaller(int[] nums)
            {
                List<int> list = new List<int>();

                int min = int.MaxValue, max = int.MinValue;
                foreach (int i in nums)
                {
                    min = min > i ? i : min;
                    max = max < i ? i : max;
                }

                SegTreeNode root = new SegTreeNode(min, max);

                for (int i = nums.Length - 1; i >= 0; i--)
                {
                    list.Insert(0, find(nums[i] - 1, root)); // minus 1, in case there will be a equal one
                    add(nums[i], root);
                }

                return list;
            }

            private int find(int x, SegTreeNode root)
            {
                if (root == null) return 0;

                if (x >= root.max)
                {
                    return root.count;
                }
                else
                {
                    int mid = root.mid();
                    if (x < mid)
                    {
                        return find(x, root.left);
                    }
                    else
                    {
                        return find(x, root.left) + find(x, root.right);
                    }
                }
            }

            private void add(int x, SegTreeNode root)
            {
                if (x < root.min || x > root.max) return;

                root.count++;
                if (root.max == root.min) return;

                int mid = root.mid();
                if (x < mid)
                {
                    if (root.left == null)
                    {
                        root.left = new SegTreeNode(root.min, mid - 1);
                    }
                    add(x, root.left);
                }
                else
                {
                    if (root.right == null)
                    {
                        root.right = new SegTreeNode(mid, root.max);
                    }
                    add(x, root.right);
                }
            }
        }

        public string LongestPalindrome(string s)
        {
            if (string.IsNullOrEmpty(s)) return string.Empty;
            var dp = new bool?[s.Length, s.Length];
            int l = 0, r = 0;
            LongestPalindromeRec3(s, 0, s.Length - 1, ref l, ref r, ref dp);
            return s.Substring(l, r - l + 1);
        }

        private bool LongestPalindromeRec3(string s, int left, int right, ref int l, ref int r, ref bool?[,] dp)
        {
            if (left > right) return true;
            if (left == right) return true;

            if (dp[left, right].HasValue)
            {
                return dp[left, right].Value;
            }

            if (s[left] == s[right])
            {
                dp[left, right] = LongestPalindromeRec3(s, left + 1, right - 1, ref l, ref r, ref dp);
            }
            else dp[left, right] = false;

            if (dp[left, right].Value)
            {
                if (r - l < right - left)
                {
                    l = left;
                    r = right;
                }
            }
            else
            {
                LongestPalindromeRec3(s, left, right - 1, ref l, ref r, ref dp);
                LongestPalindromeRec3(s, left + 1, right, ref l, ref r, ref dp);
            }

            return dp[left, right].Value;
        }


        public int LongestPalindromeSubseq(string s)
        {
            if (string.IsNullOrEmpty(s)) return 0;
            var dp = new int?[s.Length, s.Length];
            return LongestPalindromeSubseqRec(s, 0, s.Length - 1, ref dp);
        }

        private int LongestPalindromeSubseqRec(string s, int left, int right, ref int?[,] dp)
        {
            if (left > right) return 0;
            if (left == right) return 1;

            if (dp[left, right].HasValue) return dp[left, right].Value;

            if (s[left] == s[right])
            {
                dp[left, right] = 2 + LongestPalindromeSubseqRec(s, left + 1, right - 1, ref dp);
            }
            else
            {
                var option1 = LongestPalindromeSubseqRec(s, left + 1, right, ref dp);
                var option2 = LongestPalindromeSubseqRec(s, left, right - 1, ref dp);
                dp[left, right] = Math.Max(option1, option2);
            }

            return dp[left, right].Value;
        }

        public int LongestPalindrome3(string s)
        {
            if (string.IsNullOrEmpty(s)) return 0;
            var arr = new int[128];
            int result = 0;
            for (int i = 0; i < s.Length; i++)
            {
                arr[s[i]]++;
                if (arr[s[i]] >= 2)
                {
                    result += 2;
                    arr[s[i]] -= 2;
                }
            }

            return result + (arr.Sum() > 0 ? 1 : 0);
        }

        public int CoinChange(int[] coins, int amount)
        {
            var dp = new int?[coins.Length, amount + 1];
            CoinChangeRec3(coins, amount, 0, ref dp);
            var arr = dp.ToJaggedArray();
            arr.Print();
            return dp[0, amount].Value;
        }

        private int CoinChangeRec3(int[] coins, in int amount, int i, ref int?[,] dp)
        {
            if (amount == 0) return 0;
            if (amount < 0) return -1;

            if (dp[i, amount].HasValue) return dp[i, amount].Value;

            var min = int.MaxValue;
            for (int j = 0; j < coins.Length; j++)
            {
                if (coins[j] <= amount)
                {
                    var option = CoinChangeRec3(coins, amount - coins[j], j, ref dp);
                    if (option != -1)
                    {
                        min = Math.Min(option + 1, min);
                    }
                }
            }

            dp[i, amount] = min;

            return min;
        }

        //public List<int> coinChange(int[] coins, int amount)
        //{
        //    var lst = new List<int>();
        //    var dp = new int[coins.Length, amount + 1];

        //    coinChangeRec(coins, amount, ref dp, ref lst);


        //}

        //public bool coinChangeRec(int[] coins, int amount, int[,] dp, List<int> lst)
        //{
        //    if(amount < 0)
        //}


        public int Change(int amount, int[] coins)
        {
            var dp = new int[amount + 1];

            dp[0] = 1;
            foreach (var coin in coins)
            {
                for (int i = 1; i <= amount; i++)
                {
                    if (i - coin >= 0)
                        dp[i] += dp[i - coin];
                }
            }

            return dp[amount];
        }

        public int CountComponents(int n, int[][] edges)
        {
            if (n <= 0) return 0;
            if (edges == null || edges.Length == 0) return n;
            var adjList = new HashSet<int>[n];

            for (int i = 0; i < n; i++)
                adjList[i] = new HashSet<int>();

            foreach (var edge in edges)
            {
                adjList[edge[0]].Add(edge[1]);
                adjList[edge[1]].Add(edge[0]);
            }

            int components = n;
            var visited = new bool[n];
            var st = new Stack<int>();
            for (int i = 0; i < n; i++)
            {
                if (!visited[i])
                {
                    st.Push(i);
                    visited[i] = true;

                    while (st.Count > 0)
                    {
                        var node = st.Pop();
                        if (visited[node]) continue;
                        foreach (var child in adjList[node])
                        {
                            if (!visited[child])
                            {
                                components--;
                                visited[child] = true;
                                st.Push(child);
                            }
                        }
                    }
                }
            }

            return components;
        }

        public class LCSDSU
        {
            public Dictionary<int, int> parents;
            public Dictionary<int, int> rank;

            public LCSDSU(int[] M)
            {
                parents = new Dictionary<int, int>();
                rank = new Dictionary<int, int>();
                for (int i = 0; i < M.Length; i++)
                {
                    parents[M[i]] = M[i];
                    rank[M[i]] = 1;
                }

                for (int i = 0; i < M.Length; i++)
                {
                    if (parents.ContainsKey(M[i] - 1))
                        this.Union(M[i], M[i] - 1);
                    if (parents.ContainsKey(M[i] + 1))
                        this.Union(M[i], M[i] + 1);
                }
            }

            public void Union(int i, int j)
            {
                var iParent = Find(i);
                var jParent = Find(j);

                if (iParent == jParent) return;

                if (rank[iParent] < rank[jParent])
                {
                    parents[iParent] = jParent;
                    rank[jParent] += rank[iParent];
                    rank[iParent] = 0;
                }
                else
                {
                    parents[jParent] = iParent;
                    rank[iParent] += rank[jParent];
                    rank[jParent] = 0;
                }
            }

            private int Find(in int x)
            {
                if (parents[x] != x) parents[x] = Find(parents[x]);
                return parents[x];
            }
        }

        public int LongestConsecutive(int[] nums)
        {
            if (nums == null || nums.Length == 0) return 0;
            var dsu = new LCSDSU(nums);
            return dsu.rank.Select(kv => kv.Value).Max();
        }

        public class FriendsDSU
        {
            public int[] parents;
            public int[] rank;
            public int circles;

            public FriendsDSU(int[][] M)
            {
                circles = M.Length;
                parents = new int[M.Length];
                rank = new int[M.Length];
                for (int i = 0; i < parents.Length; i++)
                    parents[i] = i;

                for (int i = 0; i < M.Length; i++)
                {
                    for (int j = 0; j < M[i].Length; j++)
                    {
                        if (M[i][j] == 1)
                        {
                            this.Union(i, j);
                        }
                    }
                }
            }

            public void Union(int i, int j)
            {
                var iParent = Find(i);
                var jParent = Find(j);

                if (iParent == jParent) return;

                circles--;

                if (rank[iParent] < rank[jParent])
                {
                    parents[iParent] = jParent;
                    rank[jParent] += rank[iParent];
                    rank[iParent] = 0;
                }
                else
                {
                    parents[jParent] = iParent;
                    rank[iParent] += rank[jParent];
                    rank[jParent] = 0;
                }
            }

            private int Find(in int x)
            {
                if (parents[x] != x) parents[x] = Find(parents[x]);
                return parents[x];
            }
        }
        public int FindCircleNum(int[][] M)
        {
            var dsu = new FriendsDSU(M);
            return dsu.circles;
        }

        public int CoinChange1(int[] coins, int amount)
        {
            var dp = new int[amount + 1];
            Array.Fill(dp, amount + 1);
            dp[0] = 0;
            foreach (var coin in coins)
            {
                for (int i = 1; i <= amount; i++)
                {
                    if (i - coin >= 0)
                        dp[i] = Math.Min(dp[i], dp[i - coin] + 1);
                }
            }

            return dp[amount] == amount + 1 ? -1 : dp[amount];
        }

        public int Change1(int amount, int[] coins)
        {
            var dp = new int?[coins.Length, amount + 1];
            return ChangeRec(amount, ref coins, ref dp, 0);
        }

        private int ChangeRec(in int amount, ref int[] coins, ref int?[,] dp, int i)
        {
            if (amount == 0) return 1;
            if (amount < 0 || i == coins.Length) return 0;
            if (dp[i, amount].HasValue) return dp[i, amount].Value;

            int count = 0;
            for (int j = i; j < coins.Length; j++)
            {
                count += ChangeRec(amount - coins[j], ref coins, ref dp, j);
            }

            dp[i, amount] = count;
            return dp[i, amount].Value;
        }

        public class WordStats
        {
            public int freq;
            public int order;
        }

        public static string[,] WordCountEngine(string document)
        {
            if (string.IsNullOrEmpty(document))
            {
                return new string[0, 0];
            }

            var wordsList = document.ToLower().Split(" ", StringSplitOptions.RemoveEmptyEntries).ToArray();

            // '   '
            // ["", "", ""]

            // '.!_'
            // [".", "!", ""]

            var wordsFreq = new Dictionary<string, WordStats>();
            var wordBuilder = new StringBuilder();
            for (int i = 0; i < wordsList.Length; i++)
            {

                var word = wordsList[i];

                wordBuilder.Clear();
                foreach (var ch in word)
                {
                    if (ch >= 'a' && ch <= 'z')
                    {
                        wordBuilder.Append(ch);
                    }
                }

                word = wordBuilder.ToString();

                if (string.IsNullOrEmpty(word)) continue;

                if (wordsFreq.ContainsKey(word))
                {
                    wordsFreq[word] = new WordStats { freq = wordsFreq[word].freq + 1, order = wordsFreq[word].order };
                }
                else wordsFreq.Add(word, new WordStats { freq = 1, order = i });
            }

            var resultList = new string[wordsFreq.Keys.Count][];

            int k = 0;
            foreach (var kv in wordsFreq)
            {
                resultList[k++] = new[] { kv.Key, kv.Value.freq.ToString() };
            }

            Array.Sort(resultList, Comparer<string[]>.Create((pair1, pair2) =>
            {
                if (pair1[1] == pair2[1])
                {
                    return wordsFreq[pair1[0]].order - wordsFreq[pair2[0]].order;
                }
                return int.Parse(pair2[1]) - int.Parse(pair1[1]);
            }));

            return ToRectangular(resultList);
        }

        static T[,] ToRectangular<T>(T[][] array)
        {
            int height = array.Length, width = array[0].Length;
            T[,] rect = new T[height, width];
            for (int i = 0; i < height; i++)
            {
                T[] row = array[i];
                for (int j = 0; j < width; j++)
                {
                    rect[i, j] = row[j];
                }
            }
            return rect;
        }

        public int CoinChange2(int[] coins, int amount)
        {
            var dp = new int?[amount + 1];
            dp[0] = 0;
            Array.Sort(coins, (a, b) => b - a);
            CoinChangeRec(coins, amount, ref dp);
            return dp[amount].Value == int.MaxValue ? -1 : dp[amount].Value;
        }

        private int CoinChangeRec(int[] coins, in int rem, ref int?[] dp)
        {
            if (rem < 0) return int.MaxValue;
            if (rem == 0) return 1;
            if (dp[rem].HasValue) return dp[rem].Value;

            var sum = 0;
            for (int i = 0; i < coins.Length; i++)
            {
                if (coins[i] <= rem)
                {
                    var option = CoinChangeRec(coins, rem - coins[i], ref dp);
                    if (option != int.MaxValue)
                    {
                        sum += option;
                    }
                }
            }
            dp[rem] = sum;
            return dp[rem].Value;
        }

        public bool SearchMatrix3(int[][] matrix, int target)
        {
            if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0) return false;
            int rows = matrix.Length, cols = matrix[0].Length;

            int low = 0, high = rows * cols - 1;
            while (low <= high)
            {
                var mid = low + (high - low) / 2;

                int row = mid / cols, col = mid % cols;

                if (matrix[row][col] == target)
                    return true;
                else if (matrix[row][col] < target)
                {
                    low = mid + 1;
                }
                else high = mid - 1;
            }

            return false;
        }

        public class ArrayReader
        {
            public int Get(int index)
            {
                return 0;
            }
        }

        public int Search3(ArrayReader reader, int target)
        {
            int low = 0, high = int.MaxValue;

            while (low <= high)
            {
                var mid = low + (high - low) / 2;
                var val = reader.Get(mid);

                if (val == target) return mid;
                else if (val > target) high = mid - 1;
                else low = mid + 1;
            }

            return -1;
        }

        public int Search1(int[] nums, int target)
        {
            if (nums == null || nums.Length == 0) return -1;

            int low = 0, high = nums.Length - 1;

            while (low <= high)
            {
                var mid = low + (high - low) / 2;

                if (nums[mid] == target) return mid;
                else if (nums[mid] > target) high = mid - 1;
                else low = mid + 1;
            }

            return -1;
        }

        public bool SearchMatrix(int[][] matrix, int target)
        {
            if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0) return false;
            int i = 0, j = matrix[0].Length - 1;
            int rows = matrix.Length, cols = matrix[0].Length;

            while (i < rows && j >= 0)
            {
                if (matrix[i][j] == target) return true;
                else if (matrix[i][j] > target)
                {
                    j--;
                }
                else
                {
                    i++;
                }
            }

            return false;
        }

        public int KthSmallest(int[][] matrix, int k)
        {
            if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0 || k < 1) return -1;
            int iRow = 0, i = 0, jRow = 1, j = 0;
            int rows = matrix.Length, cols = matrix[0].Length;

            while (iRow < rows && jRow < rows && i < cols && j < cols)
            {
                k--;
                if (matrix[iRow][i] < matrix[jRow][j])
                {
                    if (k == 0) return matrix[iRow][i];
                    i++;
                    if (i == cols)
                    {
                        i = 0;
                        iRow += 2;
                    }
                }
                else
                {
                    if (k == 0) return matrix[jRow][j];
                    j++;
                    if (j == cols)
                    {
                        j = 0;
                        jRow += 2;
                    }
                }
            }

            var lastRow = rows - 1;
            var col = iRow == lastRow ? i : j;
            if (col < cols)
            {
                return k <= cols - col ? matrix[lastRow][col + k - 1] : -1;
            }

            return -1;
        }

        public int[][] Multiply(int[][] A, int[][] B)
        {
            if (A == null || B == null || A.Length == 0 || B.Length == 0) return new int[0][];
            var aList = new Dictionary<int, int>[A.Length];
            var bList = new Dictionary<int, int>[B[0].Length];
            for (int i = 0; i < A.Length; i++)
            {
                aList[i] = new Dictionary<int, int>();
                for (int j = 0; j < A[i].Length; j++)
                {
                    if (A[i][j] != 0)
                    {
                        aList[i][j] = A[i][j];
                    }
                }
            }

            for (int i = 0; i < B.Length; i++)
            {
                for (int j = 0; j < B[i].Length; j++)
                {
                    if (bList[j] == null)
                        bList[j] = new Dictionary<int, int>();
                    if (B[i][j] != 0)
                    {
                        bList[j][i] = B[i][j];
                    }
                }
            }

            var result = new int[aList.Length][];
            for (int i = 0; i < aList.Length; i++)
            {
                var row = aList[i];
                result[i] = new int[bList.Length];

                for (int j = 0; j < bList.Length; j++)
                {
                    var col = bList[j];

                    foreach (var kv in row)
                    {
                        result[i][j] += (kv.Value * (col.ContainsKey(kv.Key) ? col[kv.Key] : 0));
                    }
                }
            }

            return result;
        }

        public int LargestBSTSubtree(TreeNode root)
        {
            if (root == null) return 0;
            int max = -1;
            LargestBSTSubtreeRec(root, ref max);
            return max;
        }

        private (int path, int? min, int? max) LargestBSTSubtreeRec(TreeNode node, ref int max)
        {
            if (node == null) return (0, null, null);

            var left = LargestBSTSubtreeRec(node.left, ref max);

            var isLeftValid = left.path != -1 && (!left.min.HasValue || node.val > left.min) && (!left.max.HasValue || node.val > left.max);

            var right = LargestBSTSubtreeRec(node.right, ref max);

            var isRightValid = right.path != -1 && (!right.min.HasValue || node.val < right.min) && (!right.max.HasValue || node.val < right.max);

            if (isLeftValid && isRightValid)
            {
                max = Math.Max(1 + left.path + right.path, max);
                return (1 + left.path + right.path, left.min ?? node.val, right.max ?? node.val);
            }
            return (-1, 0, 0);
        }

        public int FindSecondMinimumValue(TreeNode root)
        {
            if (root == null || root.left == null) return -1;

            int? result = null;
            var st = new Stack<TreeNode>();
            st.Push(root.left);
            st.Push(root.right);

            while (st.Count > 0)
            {
                var node = st.Pop();

                if (node == null) continue;

                if (node.val != root.val)
                {
                    result = Math.Min(result ?? int.MaxValue, node.val);
                }

                if (node.left == null) continue;

                st.Push(node.left);
                st.Push(node.right);
            }

            return result == null ? -1 : result.Value;
        }

        public ListNode Insert(ListNode head, int insertVal)
        {
            var newVal = new ListNode(insertVal);
            if (head == null)
            {
                newVal.next = newVal;
                return newVal;
            }
            else if (head.next == head)
            {
                head.next = newVal;
                newVal.next = head;
                return head;
            }

            ListNode slow = head, fast = head.next;
            bool toInsert = false;
            do
            {
                if (insertVal >= slow.val && insertVal <= fast.val)
                {
                    toInsert = true;
                }
                else if (slow.val > fast.val)
                {
                    if (insertVal >= slow.val || insertVal <= fast.val)
                    {
                        toInsert = true;
                    }
                }

                if (toInsert)
                {
                    slow.next = newVal;
                    newVal.next = fast;
                    return head;
                }

                slow = fast;
                fast = fast.next;
            } while (slow != head);

            // Case 3).
            slow.next = newVal;
            newVal.next = fast;
            return head;
        }

        public class SparseVector
        {
            public Dictionary<int, int> vector;

            public SparseVector(int[] nums)
            {
                vector = new Dictionary<int, int>();
                for (int i = 0; i < nums.Length; i++)
                {
                    if (nums[i] != 0) vector[i] = nums[i];
                }
            }

            // Return the dotProduct of two sparse vectors
            public int DotProduct(SparseVector vec)
            {
                if (vec.vector.Count == 0 || this.vector.Count == 0) return 0;
                if (this.vector.Count > vec.vector.Count) return vec.DotProduct(this);
                int sum = 0;
                foreach (var kv in vector)
                {
                    sum += (vec.vector.ContainsKey(kv.Key) ? vec.vector[kv.Key] : 0) * kv.Value;
                }

                return sum;
            }
        }


        public int MaximumSwap(int num)
        {
            var lst = new List<int>(10);
            while (num != 0)
            {
                lst.Add(num - (num / 10 * 10));
                num /= 10;
            }

            int[] suffixMax = new int[lst.Count];
            int max = 0;
            for (int i = 1; i < lst.Count; i++)
            {
                suffixMax[i] = max;
                if (lst[i] > lst[max])
                    max = i;
            }

            for (int i = lst.Count - 1; i >= 0; i--)
            {
                if (lst[i] < lst[suffixMax[i]])
                {
                    var temp = lst[i];
                    lst[i] = lst[suffixMax[i]];
                    lst[suffixMax[i]] = temp;
                    break;
                }
            }

            lst.Reverse();
            return int.Parse(string.Concat(lst));
        }

        public bool IsNumber(string s)
        {
            if (string.IsNullOrEmpty(s)) return false;
            s = s.Trim();
            if (string.IsNullOrEmpty(s)) return false;

            bool eSeen = false, dotSeen = false, numberSeen = false;
            for (int i = 0; i < s.Length; i++)
            {
                if (char.IsDigit(s[i]))
                {
                    numberSeen = true;
                }
                else if (s[i] == '.')
                {
                    if (eSeen || dotSeen) return false;
                    dotSeen = true;
                }
                else if (s[i] == 'e')
                {
                    if (eSeen || !numberSeen) return false;
                    eSeen = true;
                    numberSeen = false;
                }
                else if (s[i] == '+' || s[i] == '-')
                {
                    if (i != 0 && s[i - 1] != 'e') return false;
                }
                else
                {
                    return false;
                }

            }

            return numberSeen;
        }

        public int minOperations(int[] arr)
        {
            int result = 0;
            for (int i = 0; i < arr.Length; i++)
            {
                if (arr[i] - 1 != i)
                {
                    var dif = arr[i] - i;
                    result++;
                    Array.Reverse(arr, i, dif);
                    i--;
                }
            }
            return result;
        }

        public double findGrantsCap(double[] grantsArray, double newBudget)
        {
            int n = grantsArray.Length;

            //# sort the array in a descending order.
            Array.Sort(grantsArray, (a, b) => (int)(b - a));

            //# pad the array with a zero at the end to
            //# cover the case where 0 <= cap <= grantsArray[i]
            var lst = grantsArray.ToList();
            lst.Add(0);

            //# calculate the total amount we need to
            //# cut back to meet the reduced budget
            var surplus = lst.Sum() - newBudget;

            /*#if there is nothing to cut, simply return
            # the highest grant as the cap. Recall that
            # the grants array is sorted in a descending
            # order, so the highest grant is positioned
            # at index 0*/
            if (surplus <= 0)
                return lst[0];

            /*# start subtracting from surplus the
            # differences (“deltas”) between consecutive
            # grants until surplus is less or equal to zero.
            # Basically, we are testing out, in order, each
            # of the grants as potential lower bound for
            # the cap. Once we find the first value that
            # brings us below zero we break*/
            var i = 0;
            for (; i < n - 1; i++)
            {
                surplus -= (i + 1) * (lst[i] - lst[i + 1]);
                if (surplus <= 0)
                    break;
            }

            /*# since grantsArray[i+1] is a lower bound
            # to our cap, i.e. grantsArray[i+1] <= cap,
            # we  need to add to grantsArray[i+1] the
            # difference: (-total / float(i+1), so the
            # returned value equals exactly to cap.*/
            return lst[i + 1] + (-surplus / (double)(i + 1));
        }

        public int Trap(int[] height)
        {
            int[] rightMax = new int[height.Length];
            for (int i = height.Length - 2; i >= 0; i--)
            {
                rightMax[i] = Math.Max(height[i + 1], rightMax[i + 1]);
            }

            int leftMax = 0, sum = 0;
            for (int i = 0; i < height.Length; i++)
            {
                sum += Math.Max(Math.Min(leftMax, rightMax[i]) - height[i], 0);
                leftMax = Math.Max(leftMax, height[i]);
            }

            return sum;
        }

        public int Trap1(int[] height)
        {
            if (height == null || height.Length < 3) return 0;
            var st = new Stack<int>();
            int sum = 0;
            for (int i = 0; i < height.Length; i++)
            {
                while (st.Count != 0 && height[st.Peek()] < height[i])
                {
                    var mid = st.Pop();
                    if (st.Count > 0)
                    {
                        sum += (Math.Min(height[st.Peek()], height[i]) - height[mid]) * (i - st.Peek() - 1);
                    }
                }

                st.Push(i);
            }

            return sum;
        }

        public double FindGrantsCap(double[] grantsArray, double newBudget)
        {
            int n = grantsArray.Length;
            Array.Sort(grantsArray);
            var prefixSum = new double[n];
            double sum = 0;
            for (var i = 0; i < n; i++)
            {
                sum += grantsArray[i];
                prefixSum[i] = sum;
            }

            double low = 0, high = newBudget;

            while (low <= high)
            {
                var cap = low + (high - low) / 2; // 95

                var capLocation = Array.BinarySearch(grantsArray, cap);
                if (capLocation < 0)
                {
                    capLocation = ~capLocation;
                }
                else capLocation += 1;

                var leftUnchangedGrants = capLocation > 0 ? prefixSum[capLocation - 1] : 0;

                var rightGrants = (n - capLocation) * cap;

                var grantsSum = rightGrants + leftUnchangedGrants;

                if (grantsSum == newBudget)
                {
                    return Math.Round(cap, 2);
                }
                else if (grantsSum < newBudget)
                {
                    low = cap;
                }
                else high = cap;
            }

            return Math.Round(low, 2);
        }


        public int Divide(int dividend, int divisor)
        {
            if (dividend == int.MinValue && divisor == -1)
                return int.MaxValue;

            var negative = 2;
            if (dividend > 0)
            {
                negative--;
                dividend = -dividend;
            }

            if (divisor > 0)
            {
                negative--;
                divisor = -divisor;
            }

            var doubles = -1;
            var divisorsList = new List<int> { divisor };
            var quotientList = new List<int> { doubles };
            var tempDivisor = divisor;
            int halfMin = -(int)Math.Pow(2, 30);
            while (tempDivisor >= halfMin && dividend <= tempDivisor + tempDivisor)
            {
                tempDivisor += tempDivisor;
                doubles += doubles;
                quotientList.Add(doubles);
                divisorsList.Add(tempDivisor);
            }

            int quotient = 0;
            for (int i = divisorsList.Count - 1; i >= 0; i--)
            {
                if (divisorsList[i] >= dividend)
                {
                    quotient += quotientList[i];
                    dividend -= divisorsList[i];
                }
            }

            if (negative != 1)
            {
                quotient = -quotient;
            }

            return quotient;
        }

        public int RomanToInt(string s)
        {
            if (string.IsNullOrEmpty(s)) return 0;
            var dic = new Dictionary<string, int>
            {
                {"I", 1},
                {"V", 5},
                {"X", 10},
                {"L", 50},
                {"C", 100},
                {"D", 500},
                {"M", 1000},
                {"IV", 4},
                {"IX", 9},
                {"XL", 40},
                {"XC", 90},
                {"CD", 400},
                {"CM", 900},
            };

            var num = 0;
            for (int i = 0; i < s.Length; i++)
            {
                var st = s[i] + (i + 1 < s.Length ? s[i + 1].ToString() : "");
                if (dic.ContainsKey(st))
                {
                    num += dic[st];
                    i++;
                }
                else num += dic[s[i].ToString()];
            }

            return num;
        }

        char[] operators = new[] { '+', '-', '*' };
        public IList<string> AddOperators(string num, int target)
        {
            if (string.IsNullOrEmpty(num)) return new List<string>();
            var lst = new List<string>();
            var sb = new StringBuilder();
            AddOperatorsRec(num, 0, target, '+', 0, '+', ref sb, ref lst);
            return lst;
        }

        private void AddOperatorsRec(string num, int i, in int target, char op, int resultSoFar, char lastOp, ref StringBuilder sb, ref List<string> lst)
        {
            var n = num[i] - 48;
            var lastOperand = i == 0 ? 0 : (num[i - 1] - 48);
            var prevResult = resultSoFar;
            switch (op)
            {
                case '+':
                    resultSoFar += n;
                    break;
                case '-':
                    resultSoFar -= n;
                    break;
                case '*':
                    if (lastOp != '*')
                    {
                        if (lastOp == '+')
                        {
                            resultSoFar -= lastOperand;
                            resultSoFar = resultSoFar + (lastOperand * n);
                        }
                        else
                        {
                            resultSoFar += lastOperand;
                            resultSoFar = resultSoFar - (lastOperand * n);
                        }
                    }
                    else resultSoFar = resultSoFar * n;
                    break;
                default:
                    if (lastOp == ' ')
                    {
                        resultSoFar *= 10;
                        resultSoFar += n;
                    }
                    else
                    {
                        switch (lastOp)
                        {
                            case '+':
                                resultSoFar -= lastOperand;
                                break;
                            case '-':
                                resultSoFar += lastOperand;
                                break;
                            case '*':
                                resultSoFar /= lastOperand;
                                break;
                        }
                        lastOperand *= 10;
                        lastOperand += n;

                        switch (lastOp)
                        {
                            case '+':
                                resultSoFar += lastOperand;
                                break;
                            case '-':
                                resultSoFar -= lastOperand;
                                break;
                            case '*':
                                resultSoFar *= lastOperand;
                                break;
                        }
                    }

                    break;
            }

            sb.Append(num[i]);

            if (i == num.Length - 1)
            {
                if (resultSoFar == target)
                    lst.Add(sb.ToString());
                sb.Length--;
                return;
            }

            if (resultSoFar > 0)
            {
                AddOperatorsRec(num, i + 1, target, ' ', resultSoFar, op, ref sb, ref lst);
            }

            foreach (var @operator in operators)
            {
                sb.Append(@operator);
                AddOperatorsRec(num, i + 1, target, @operator, resultSoFar, op, ref sb, ref lst);
                sb.Length--;
            }

            sb.Length--;
        }

        private int EvaluateExpression(string expression)
        {
            return (int)new DataTable().Compute(expression, "");
        }

        public int MaxSubArrayLen(int[] nums, int k)
        {
            if (nums == null || nums.Length == 0) return 0;
            var prefixSum = 0;
            int max = 0;
            var dic = new Dictionary<int, int> { { 0, -1 } };
            for (int i = 0; i < nums.Length; i++)
            {
                prefixSum += nums[i];
                if (dic.ContainsKey(prefixSum - k))
                    max = Math.Max(i - dic[prefixSum - k], max);

                if (!dic.ContainsKey(prefixSum))
                    dic.Add(prefixSum, i);
            }

            return max;
        }


        public string AddStrings(string num1, string num2)
        {
            if (string.IsNullOrEmpty(num1) && string.IsNullOrEmpty(num2)) return string.Empty;
            if (string.IsNullOrEmpty(num1)) return num2;
            if (string.IsNullOrEmpty(num2)) return num1;

            var sb = new StringBuilder();
            int i = num1.Length - 1, j = num2.Length - 1;

            int carry = 0;
            while (i >= 0 || j >= 0)
            {
                var sum = carry + (i >= 0 ? num1[i] - '0' : 0) + (j >= 0 ? num2[j] - '0' : 0);
                sb.Insert(0, sum % 10);
                carry = sum / 10;
                i--;
                j--;
            }

            if (carry > 0)
            {
                sb.Insert(0, carry);
            }

            return sb.ToString();
        }

        public int FindKthLargest(int[] nums, int k)
        {
            if (nums == null || nums.Length == 0 || k > nums.Length || k < 1) return -1;
            return QuickSelect(nums, 0, nums.Length - 1, nums.Length - k);
        }

        private int QuickSelect(int[] nums, int left, in int right, in int k)
        {
            int pivot = nums[right], writeIndex = left, temp;
            for (int i = left; i < right; i++)
            {
                if (nums[i] <= pivot)
                {
                    temp = nums[writeIndex];
                    nums[writeIndex++] = nums[i];
                    nums[i] = temp;
                }
            }

            temp = nums[writeIndex];
            nums[writeIndex] = nums[right];
            nums[right] = temp;

            var orderSize = writeIndex - left;
            if (orderSize == k) return nums[writeIndex];
            else if (orderSize > k)
            {
                return QuickSelect(nums, left, writeIndex - 1, k);
            }
            else
            {
                return QuickSelect(nums, writeIndex + 1, right, k - orderSize - 1);
            }
        }

        public int ThreeSumSmaller(int[] nums, int target)
        {
            Array.Sort(nums);

            int i = 0, count = 0;

            while (i < nums.Length)
            {
                int low = i + 1, high = nums.Length - 1;
                while (low < high)
                {
                    var sum = nums[i] + nums[low] + nums[high];

                    if (sum < target)
                    {
                        count += high - low;
                        low++;
                    }
                    else
                    {
                        high--;
                    }
                }
                i++;
            }

            return count;
        }

        public string MinRemoveToMakeValidBetter(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;
            var sb = new StringBuilder(s.Length);
            var st = new Stack<int>();
            for (int i = 0; i < s.Length; i++)
            {
                switch (s[i])
                {
                    case '(':
                        sb.Append(s[i]);
                        st.Push(sb.Length - 1);
                        break;
                    case ')':
                        if (st.Count > 0)
                        {
                            sb.Append(s[i]);
                            st.Pop();
                        }
                        break;
                    default:
                        sb.Append(s[i]);
                        break;
                }
            }

            while (st.Count > 0)
            {
                sb.Remove(st.Pop(), 1);
            }

            return sb.ToString();
        }

        public int LeastInterval(char[] tasks, int n)
        {
            var freq = new int[26];

            foreach (var task in tasks)
                freq[task - 'a']++;

            Array.Sort(freq);

            int idleSections = freq[freq.Length - 1] - 1;
            var idleTime = (idleSections) * n;

            for (int i = freq.Length - 2; i >= 0 && idleTime > 0; i--)
            {
                idleTime -= Math.Min(idleSections, freq[i]);
            }

            idleTime = Math.Max(0, idleTime);

            return idleTime + tasks.Length;
        }

        public string LongestPalindrome1(string s)
        {
            if (string.IsNullOrEmpty(s) || s.Length <= 1) return s;
            var dp = new bool[s.Length, s.Length];
            int minLeft = 0, maxRight = 0;

            for (int i = 0; i < s.Length; i++)
            {
                dp[i, i] = true;
            }

            for (int i = s.Length - 1; i >= 0; i--)
            {
                for (int j = i + 1; j < s.Length; j++)
                {
                    if (s[i] == s[j])
                    {
                        if (j - i == 1 || dp[i + 1, j - 1])
                        {
                            dp[i, j] = true;
                            if (j - i >= maxRight - minLeft)
                            {
                                minLeft = i;
                                maxRight = j;
                            }
                        }
                    }
                }
            }

            return s.Substring(minLeft, maxRight - minLeft + 1);
        }

        public string LongestPalindrome2(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;

            var dp = new bool?[s.Length, s.Length];
            int min = 0, max = 0;
            LongestPalindromeRec(s, 0, s.Length - 1, ref min, ref max, ref dp);

            return s.Substring(min == int.MaxValue ? 0 : min, min == int.MaxValue ? 1 : max - min + 1);
        }

        private bool LongestPalindromeRec(string s, int left, int right, ref int minX, ref int maxX, ref bool?[,] dp)
        {
            if (left >= right) return true;
            if (dp[left, right].HasValue) return dp[left, right].Value;

            bool isPalindrome = false;
            if (s[left] == s[right])
            {
                isPalindrome = LongestPalindromeRec(s, left + 1, right - 1, ref minX, ref maxX, ref dp);
            }

            if (!isPalindrome)
            {
                LongestPalindromeRec(s, left + 1, right, ref minX, ref maxX, ref dp);
                LongestPalindromeRec(s, left, right - 1, ref minX, ref maxX, ref dp);
            }

            if (isPalindrome)
            {
                if (minX == int.MaxValue || maxX - minX < right - left)
                {
                    minX = left;
                    maxX = right;
                }
            }

            dp[left, right] = isPalindrome;
            return dp[left, right].Value;
        }

        public string LongestPalindrome11(string s)
        {
            if (string.IsNullOrEmpty(s) || s.Length <= 1) return s;
            var dp = new int?[s.Length, s.Length];
            int minLeft = 0, maxRight = 0;
            var ans = LongestPalindromeRec(s, 0, s.Length - 1, ref minLeft, ref maxRight, ref dp);
            return s.Substring(minLeft, maxRight - minLeft + 1);
        }

        private int LongestPalindromeRec(string s, int left, int right, ref int minLeft, ref int maxRight, ref int?[,] dp)
        {
            if (left > right) return 0;

            if (left == right)
            {
                dp[left, right] = 1;
            }

            if (dp[left, right].HasValue) return dp[left, right].Value;

            var ans = 0;
            if (s[left] == s[right])
                ans = 2 + LongestPalindromeRec(s, left + 1, right - 1, ref minLeft, ref maxRight, ref dp);
            ans = Math.Max(ans, LongestPalindromeRec(s, left + 1, right, ref minLeft, ref maxRight, ref dp));
            ans = Math.Max(ans, LongestPalindromeRec(s, left, right - 1, ref minLeft, ref maxRight, ref dp));

            dp[left, right] = ans;
            if (ans > maxRight - minLeft + 1)
            {
                maxRight = right;
                minLeft = left;
            }
            return ans;
        }

        public int[][] IntervalIntersection(int[][] A, int[][] B)
        {
            int a = 0, b = 0;
            List<int[]> result = new List<int[]>();
            while (a < A.Length && b < B.Length)
            {
                int low = Math.Max(A[a][0], B[b][0]);
                int high = Math.Min(A[a][1], B[b][1]);
                if (low <= high)
                    result.Add(new[] { low, high });

                if (A[a][1] < B[b][1])
                    a++;
                else b++;
            }

            return result.ToArray();
        }

        public bool IsAlienSorted(string[] words, string order)
        {
            if (words == null || words.Length <= 1) return true;
            var orderMap = new Dictionary<char, int>();
            for (int i = 0; i < order.Length; i++)
            {
                orderMap.Add(order[i], i);
            }

            for (int i = 0; i < words.Length - 1; i++)
            {
                var minLength = Math.Min(words[i].Length, words[i + 1].Length);
                int j = 0;
                for (; j < minLength; j++)
                {
                    if (words[i][j] != words[i + 1][j])
                    {
                        if (orderMap[words[i][j]] > orderMap[words[i + 1][j]])
                            return false;
                        break;
                    }
                }

                if (j == minLength && words[i].Length > words[i + 1].Length) return false;
            }

            return true;
        }

        public double[] SampleStats(int[] count)
        {
            if (count == null || count.Length == 0) return new double[] { 0, 0, 0, 0, 0 };
            int cnt = count.Sum(), min = 256, max = -1, mode = 0, maxOccValue = 0;
            double median = 0, sum = 0;
            for (int i = 0; i < count.Length; i++)
            {
                if (count[i] > 0)
                {
                    sum += count[i] * i / (double)cnt;
                    min = Math.Min(min, i);
                    max = Math.Max(max, i);
                    if (count[i] > maxOccValue)
                    {
                        mode = i;
                        maxOccValue = count[i];
                    }
                }
            }

            int mid = cnt / 2;
            for (int i = 0; i < count.Length; i++)
            {
                if (count[i] > 0)
                {
                    if (cnt % 2 == 1)
                    {
                        if (mid <= count[i])
                        {
                            median = i;
                            break;
                        }

                    }
                    else
                    {
                        if (mid <= count[i])
                        {
                            median += i;
                            if (median > i)
                            {
                                median /= 2;
                                break;
                            }
                        }

                        if (mid + 1 <= count[i])
                        {
                            median += i;
                            median /= 2;
                            break;
                        }
                    }
                    mid -= count[i];
                }
            }

            return new[] { min, max, sum, median, mode };
        }

        public ListNode AddTwoNumbers(ListNode l1, ListNode l2)
        {
            if (l1 == null || l2 == null) return l1 ?? l2;
            ListNode node1 = l1, node2 = l2, newNode = new ListNode(-1), newRoot = newNode;
            int carry = 0;
            while (node1 != null || node2 != null)
            {
                var sum = carry + (node1?.val ?? 0) + (node2?.val ?? 0);

                newNode.next = new ListNode(sum % 10);

                carry = sum / 10;

                node1 = node1?.next;
                node2 = node2?.next;
                newNode = newNode.next;
            }

            if (carry > 0)
            {
                newNode.next = new ListNode(carry);
            }

            return newRoot.next;
        }

        public string MinWindow(string s, string t)
        {
            if (string.IsNullOrEmpty(s) || string.IsNullOrEmpty(t) || t.Length > s.Length) return string.Empty;
            var dic = new Dictionary<char, int>();
            int[] sOcc = new int[128], tOcc = new int[128];

            for (int j = 0; j < t.Length; j++)
            {
                tOcc[t[j]]++;
            }
            int left = 0, right = 0, min = int.MaxValue, minLeft = 0;

            while (right < s.Length)
            {
                sOcc[s[right]]++;
                right++;

                while (left < right && Contains(sOcc, tOcc))
                {
                    if (right - left < min)
                    {
                        min = right - left;
                        minLeft = left;
                    }
                    sOcc[s[left]]--;
                    left++;
                }
            }

            return min == int.MaxValue ? string.Empty : s.Substring(minLeft, min);
        }

        private bool Contains(int[] sOcc, int[] tOcc)
        {
            for (int i = 0; i < sOcc.Length; i++)
            {
                if (sOcc[i] < tOcc[i]) return false;
            }

            return true;
        }

        public bool IsMatch(string s, string p)
        {
            var dp = new bool[s.Length + 1, p.Length + 1];

            dp[0, 0] = true;

            for (int i = 1; i < p.Length; i++)
            {
                if (p[i] == '*')
                {
                    dp[0, i] = dp[0, i - 2];
                }
            }

            for (int i = 1; i < s.Length; i++)
            {
                for (int j = 1; j < p.Length; j++)
                {
                    if (s[i - 1] == p[j - 1] || p[j - 1] == '.')
                    {
                        dp[i, j] = dp[i - 1, j - 1];
                    }
                    else
                    {
                        if (p[j - 1] == '*')
                        {
                            bool prevCharMatch = p[j - 2] == '.' || p[j - 2] == s[i - 1];
                            dp[i, j] = (prevCharMatch && dp[i - 1, j]) || dp[i, j - 2];
                        }
                    }
                }
            }

            return dp[s.Length, p.Length];
        }

        public bool IsMatch1(string s, string p)
        {
            var dp = new bool?[s.Length + 1, p.Length + 1];

            return IsMatchRec(s, p, 0, 0, ref dp);
        }

        private bool IsMatchRec(string s, string p, int si, int pi, ref bool?[,] dp)
        {
            if (dp[si, pi].HasValue) return dp[si, pi].Value;

            bool ans = false;
            if (pi == p.Length) ans = si == s.Length;
            else
            {
                var isFirstMatch = si < s.Length && (s[si] == p[pi] || p[pi] == '.');
                if (pi + 1 < p.Length && p[pi + 1] == '*')
                {
                    ans = (isFirstMatch && IsMatchRec(s, p, si + 1, pi, ref dp))
                          || IsMatchRec(s, p, si, pi + 2, ref dp);
                }
                else if (isFirstMatch)
                {
                    ans = IsMatchRec(s, p, si + 1, pi + 1, ref dp);
                }
            }

            dp[si, pi] = ans;

            return ans;
        }

        public TreeNode constructFromPrePost(int[] pre, int[] post)
        {
            int N = pre.Length;
            if (N == 0) return null;
            TreeNode root = new TreeNode(pre[0]);
            if (N == 1) return root;

            int L = 0;
            for (int i = 0; i < N; ++i)
                if (post[i] == pre[1])
                    L = i + 1;

            root.left = constructFromPrePost(pre.Skip(1).Take(L).ToArray(),
                post.Take(L).ToArray());
            root.right = constructFromPrePost(pre.Skip(L).Take(N - L).ToArray(),
                post.Skip(L - 1).Take(N - L).ToArray());
            return root;
        }

        public TreeNode BuildTree(int[] inorder, int[] postorder)
        {
            if (postorder == null || inorder == null || postorder.Length == 0 || inorder.Length == 0) return null;
            var nodeIndex = new Dictionary<int, int>();
            for (int i = 0; i < inorder.Length; i++)
                nodeIndex.Add(inorder[i], i);

            int preOrderIdx = inorder.Length - 1;
            return BuildTreeRec(ref postorder, ref preOrderIdx, 0, postorder.Length, nodeIndex);
        }

        private TreeNode BuildTreeRec(ref int[] postorder, ref int postOrderIdx, int inOrderLeft, in int inOrderRight, Dictionary<int, int> nodeIndex)
        {
            if (inOrderLeft == inOrderRight) return null;

            var node = new TreeNode(postorder[postOrderIdx]);

            postOrderIdx--;

            var nodeIdxInOrder = nodeIndex[node.val];
            node.right = BuildTreeRec(ref postorder, ref postOrderIdx, nodeIdxInOrder + 1, inOrderRight, nodeIndex);
            node.left = BuildTreeRec(ref postorder, ref postOrderIdx, inOrderLeft, nodeIdxInOrder, nodeIndex);

            return node;
        }

        public TreeNode BuildTree_PreOrder(int[] preorder, int[] inorder)
        {
            if (preorder == null || inorder == null || preorder.Length == 0 || inorder.Length == 0) return null;
            var nodeIndex = new Dictionary<int, int>();
            for (int i = 0; i < inorder.Length; i++)
                nodeIndex.Add(inorder[i], i);

            int preOrderIdx = 0;
            return BuildTreeRec1(ref preorder, ref preOrderIdx, 0, preorder.Length, nodeIndex);
        }

        private TreeNode BuildTreeRec1(ref int[] preorder, ref int preOrderIdx, int inOrderLeft, in int inOrderRight, Dictionary<int, int> nodeIndex)
        {
            if (inOrderLeft == inOrderRight) return null;

            var node = new TreeNode(preorder[preOrderIdx]);

            preOrderIdx++;

            var nodeIdxInOrder = nodeIndex[node.val];
            node.left = BuildTreeRec1(ref preorder, ref preOrderIdx, inOrderLeft, nodeIdxInOrder, nodeIndex);
            node.right = BuildTreeRec1(ref preorder, ref preOrderIdx, nodeIdxInOrder + 1, inOrderRight, nodeIndex);

            return node;
        }

        public int[] ProductExceptSelf(int[] nums)
        {
            if (nums == null || nums.Length == 0) return nums;
            int[] prefix = new int[nums.Length];
            int productSoFar = 1;

            for (int i = 0; i < nums.Length; i++)
            {
                prefix[i] = productSoFar;
                productSoFar *= nums[i];
            }

            productSoFar = 1;
            for (int i = nums.Length - 1; i >= 0; i--)
            {
                prefix[i] *= productSoFar;
                productSoFar *= nums[i];
            }

            return prefix;
        }

        public bool IsBipartite(int[][] graph)
        {
            if (graph == null || graph.Length < 2) return true;

            var labelsDic = new Dictionary<int, int>();
            var s = new Stack<int>();
            var visited = new bool[graph.Length];
            for (int i = graph.Length - 1; i >= 0; i--)
                s.Push(i);

            while (s.Count > 0)
            {
                var parent = s.Pop();
                if (visited[parent]) continue;
                visited[parent] = true;
                if (!labelsDic.ContainsKey(parent))
                    labelsDic[parent] = 1;
                var children = graph[parent];
                foreach (var child in children)
                {
                    if (labelsDic.ContainsKey(child))
                    {
                        if (labelsDic[child] == labelsDic[parent])
                            return false;
                    }
                    else
                    {
                        labelsDic[child] = 3 - labelsDic[parent];
                    }

                    if (!visited[child])
                    {
                        s.Push(child);
                    }
                }
            }

            return true;
        }

        public string One(int num)
        {
            var word = "";
            switch (num)
            {
                case 1:
                    word = "One";
                    break;
                case 2:
                    word = "Two";
                    break;
                case 3:
                    word = "Three";
                    break;
                case 4:
                    word = "Four";
                    break;
                case 5:
                    word = "Five";
                    break;
                case 6:
                    word = "Six";
                    break;
                case 7:
                    word = "Seven";
                    break;
                case 8:
                    word = "Eight";
                    break;
                case 9:
                    word = "Nine";
                    break;
            }
            return word;
        }

        public string BelowTwenty(int num)
        {
            var word = "";
            switch (num)
            {
                case 11:
                    word = "Eleven";
                    break;
                case 12:
                    word = "Twelve";
                    break;
                case 13:
                    word = "Thirteen";
                    break;
                case 14:
                    word = "Fourteen";
                    break;
                case 15:
                    word = "Fifteen";
                    break;
                case 16:
                    word = "Sixteen";
                    break;
                case 17:
                    word = "Seventeen";
                    break;
                case 18:
                    word = "Eighteen";
                    break;
                case 19:
                    word = "Nineteen";
                    break;
            }
            return word;
        }

        public string Ten(int num)
        {
            var word = "";
            switch (num)
            {
                case 1:
                    word = "Ten";
                    break;
                case 2:
                    word = "Twenty";
                    break;
                case 3:
                    word = "Thirty";
                    break;
                case 4:
                    word = "Forty";
                    break;
                case 5:
                    word = "Fifty";
                    break;
                case 6:
                    word = "Sixty";
                    break;
                case 7:
                    word = "Seventy";
                    break;
                case 8:
                    word = "Eighty";
                    break;
                case 9:
                    word = "Ninety";
                    break;
            }
            return word;
        }

        public string Two(int num)
        {
            if (num % 10 == 0) return Ten(num / 10);
            if (num > 10 && num < 20) return BelowTwenty(num);

            var word = Ten(num / 10);
            var one = One(num % 10);
            if (one != string.Empty)
                word += (word.Length > 0 ? " " : "") + one;
            return word;
        }

        public string Three(int num)
        {
            var word = string.Empty;
            if (num / 100 != 0) word = One(num / 100) + " Hundred";
            var two = Two(num % 100);
            if (two != string.Empty)
                word += (word.Length > 0 ? " " : "") + two;
            return word;
        }

        public string NumberToWords(int num)
        {
            if (num == 0) return "Zero";
            int billion = num / 1_000_000_000;
            int million = (num - billion * 1_000_000_000) / 1_000_000;
            int thousand = ((num - billion * 1_000_000_000) - (million * 1_000_000)) / 1_000;
            int rem = (num - billion * 1_000_000_000) - (million * 1_000_000) - (thousand * 1_000);

            var sb = new StringBuilder();
            if (billion > 0)
            {
                sb.Append(Three(billion) + " Billion");
            }

            if (million > 0)
            {
                if (sb.Length > 0) sb.Append(" ");
                sb.Append(Three(million) + " Million");
            }

            if (thousand > 0)
            {
                if (sb.Length > 0) sb.Append(" ");
                sb.Append(Three(thousand) + " Thousand");
            }

            if (rem > 0)
            {
                if (sb.Length > 0) sb.Append(" ");
                sb.Append(Three(rem));
            }

            return sb.ToString();
        }

        public bool CheckSubarraySum(int[] nums, int k)
        {
            if (nums.Length == 0) return false;
            var dic = new Dictionary<int, int>
            {
                {0, -1}
            };
            int sum = 0;
            for (int i = 0; i < nums.Length; i++)
            {
                var num = nums[i];
                sum += num;

                if (k != 0)
                    sum = sum % k;

                if (dic.ContainsKey(sum))
                {
                    if (i - dic[sum] > 1) return true;
                }
                else dic.Add(sum, i);
            }

            return false;
        }

        public int NumDecodings(string s)
        {
            var dic = new Dictionary<int, int>();
            return NumDecodingsRec(s, 0, ref dic);
        }

        private int NumDecodingsRec(string s, int i, ref Dictionary<int, int> memo)
        {
            if (s.Length == i) return 1;

            if (memo.ContainsKey(i)) return memo[i];

            var option1 = 0;
            if (s[i] - 48 > 0)
            {
                option1 = NumDecodingsRec(s, i + 1, ref memo);
            }

            int option2 = 0;
            if (s.Length - i >= 2 && s[i] != '0')
            {
                var num = (s[i] - 48) * 10 + (s[i + 1] - 48);
                if (num > 0 && num <= 26)
                {
                    option2 = NumDecodingsRec(s, i + 2, ref memo);
                }
            }

            memo[i] = option1 + option2;

            return memo[i];
        }

        public LsNode TreeToDoublyList(LsNode root)
        {
            if (root == null) return root;
            var s = new Stack<LsNode>();
            var min = AddToStack(s, root);

            LsNode prev = null;
            while (s.Count > 0)
            {
                var next = s.Pop();
                if (next.right != null) AddToStack(s, next.right);

                if (prev != null)
                    prev.right = next;
                next.left = prev;
                prev = next;
            }

            if (prev != null) prev.right = min;
            min.left = prev;
            return min;
        }

        private LsNode AddToStack(Stack<LsNode> s, LsNode node)
        {
            var lastNode = node;
            while (node != null)
            {
                s.Push(node);
                lastNode = node;
                node = node.left;
            }
            return lastNode;
        }

        public int[] countSubarrays(int[] arr)
        {
            var st = new Stack<int>();
            var result = new int[arr.Length];

            for (int i = 0; i < arr.Length; i++)
            {
                while (st.Count > 0 && arr[i] > arr[st.Peek()])
                {
                    st.Pop();
                }

                result[i] = i - (st.Count == 0 ? -1 : st.Peek());

                st.Push(i);
            }

            st.Clear();
            for (int i = arr.Length - 1; i >= 0; i--)
            {
                while (st.Count > 0 && arr[i] > arr[st.Peek()])
                {
                    st.Pop();
                }

                result[i] += (st.Count == 0 ? arr.Length : st.Peek()) - i - 1;

                st.Push(i);
            }

            return result;
        }

        public class LRUCache
        {
            public class LSNode
            {
                public LSNode(int key = -1, int val = -1)
                {
                    this.val = val;
                    this.key = key;
                }

                public int key;
                public int val;
                public LSNode next;
                public LSNode prev;
            }

            private LSNode head = new LSNode(), tail = new LSNode();
            private Dictionary<int, LSNode> dic = new Dictionary<int, LSNode>();
            private readonly int _capacity;

            public LRUCache(int capacity)
            {
                _capacity = capacity;
                //tail = head;
                head.next = tail;
                tail.prev = head;
            }

            public int Get(int key)
            {
                if (dic.ContainsKey(key))
                {
                    var node = dic[key];
                    AddToTail(node);
                    return dic[key].val;
                }

                return -1;
            }

            private void AddToTail(LSNode node)
            {
                node.prev.next = node.next;
                if (node.next != null) node.next.prev = node.prev;

                node.prev = tail.prev;
                node.prev.next = node;
                tail.prev = node;
                node.next = tail;
            }

            public void Put(int key, int value)
            {
                LSNode node;
                LSNode toBeRemoved = null;
                if (dic.ContainsKey(key))
                {
                    node = dic[key];
                    node.val = value;
                    AddToTail(node);
                }
                else
                {
                    node = new LSNode(key, value);
                    dic.Add(key, node);

                    if (dic.Keys.Count > _capacity)
                    {
                        toBeRemoved = head.next;
                        dic.Remove(toBeRemoved.key);
                        head.next = toBeRemoved.next;
                        if (toBeRemoved.next != null) toBeRemoved.next.prev = head;
                    }

                    node.next = tail;
                    node.prev = tail.prev;
                    tail.prev.next = node;
                    tail.prev = node;
                }
            }
        }

        public class BSTIterator
        {
            Stack<TreeNode> st = new Stack<TreeNode>();

            public BSTIterator(TreeNode root)
            {
                while (root != null)
                {
                    st.Push(root);
                    root = root.left;
                }
            }

            /** @return the next smallest number */
            public int Next()
            {
                var node = st.Pop();
                var val = node.val;
                if (node.right != null)
                {
                    st.Push(node.right);
                    node = node.right;
                    while (node.left != null)
                    {
                        st.Push(node.left);
                        node = node.left;
                    }
                }

                return val;
            }

            /** @return whether we have a next smallest number */
            public bool HasNext()
            {
                return st.Count > 0;
            }
        }

        public class Codec
        {
            public String rserialize(TreeNode root, String str)
            {
                // Recursive serialization.
                if (root == null)
                {
                    str += "null,";
                }
                else
                {
                    str += root.val + ",";
                    str = rserialize(root.left, str);
                    str = rserialize(root.right, str);
                }
                return str;
            }

            // Encodes a tree to a single string.
            public String serialize1(TreeNode root)
            {
                return rserialize(root, "");
            }

            // Encodes a tree to a single string.
            public string serialize(TreeNode root)
            {
                if (root == null)
                    return string.Empty;
                var sb = new StringBuilder();

                var q = new Queue<TreeNode>();
                q.Enqueue(root);
                while (q.Count > 0)
                {
                    var node = q.Dequeue();
                    sb.Append(node == null ? "null" : node.val.ToString());
                    if (node != null) q.Enqueue(node.left);
                    if (node != null) q.Enqueue(node.right);
                    if (q.Count > 0) sb.Append('|');
                }

                return sb.ToString();
            }

            // Decodes your encoded data to tree.
            public TreeNode deserialize(string data)
            {
                if (string.IsNullOrEmpty(data)) return null;
                var arr = data.Split('|').ToArray();
                var root = new TreeNode(int.Parse(arr[0]));
                var q = new Queue<TreeNode>();
                q.Enqueue(root);
                int lastIdx = 1;
                while (q.Count > 0)
                {
                    var node = q.Dequeue();
                    if (arr[lastIdx] != "null")
                    {
                        node.left = new TreeNode(int.Parse(arr[lastIdx]));
                        q.Enqueue(node.left);
                    }

                    lastIdx++;

                    if (arr[lastIdx] != "null")
                    {
                        node.right = new TreeNode(int.Parse(arr[lastIdx]));
                        q.Enqueue(node.right);
                    }

                    lastIdx++;
                }

                return root;
            }
        }

        public bool WordBreak(string s, IList<string> wordDict)
        {
            var dic = new Dictionary<int, int>();
            var st = new Stack<int>();
            foreach (var word in wordDict)
            {
                int index = -1;
                while ((index = s.IndexOf(word, index + 1)) >= 0)
                {
                    if (dic.ContainsKey(index))
                    {
                        dic[index] = Math.Max(dic[index], word.Length + index);
                    }
                    else dic.Add(index, word.Length + index);
                    if (index == 0) st.Push(word.Length + index);
                }
            }

            // (0,3), (0,7)
            // (3,5), (3,8)
            while (st.Count > 0)
            {
                var occurrence = st.Pop();
                if (occurrence == s.Length) return true;
                if (dic.ContainsKey(occurrence))
                {
                    st.Push(dic[occurrence]);
                }
            }

            return false;
        }

        public bool WordBreak_DP(string s, IList<string> wordDict)
        {
            var dp = new bool?[s.Length];
            return WordBreakRec(s, 0, wordDict.ToHashSet(), ref dp);
        }

        private bool WordBreakRec(string s, int start, HashSet<string> words, ref bool?[] dp)
        {
            if (start == s.Length) return true;

            if (dp[start].HasValue) return dp[start].Value;

            var sb = new StringBuilder();
            for (int end = start; end < s.Length; end++)
            {
                sb.Append(s[end]);
                if (words.Contains(sb.ToString()) && WordBreakRec(s, end + 1, words, ref dp))
                {
                    dp[start] = true;
                    return dp[start].Value;
                }
            }

            dp[start] = false;
            return dp[start].Value;
        }

        public int LengthOfLongestSubstringKDistinct(string s, int k)
        {
            if (k <= 0 || string.IsNullOrEmpty(s)) return 0;
            var countDic = new Dictionary<char, int>();

            int left = 0, right = 0;

            int max = 0;
            while (right != s.Length)
            {
                if (!countDic.ContainsKey(s[right]))
                    countDic.Add(s[right], 0);
                countDic[s[right]]++;

                while (countDic.Keys.Count > k)
                {
                    countDic[s[left]]--;
                    if (countDic[s[left]] == 0) countDic.Remove(s[left]);
                    left++;
                }

                max = Math.Max(max, right - left + 1);
                right++;
            }

            return max;
        }

        public int MySqrt(int x)
        {
            if (x < 2) return x;
            int left = 2, right = x / 2;

            while (left <= right)
            {
                int mid = left + (right - left) / 2;
                long multiply = mid * mid;

                if (multiply > x)
                {
                    right = mid - 1;
                }
                else if (multiply < x) left = mid + 1;
                else return mid;
            }

            return right;
        }

        public int MySqrt1(int x)
        {
            return MySqrtRec(x);
        }

        private int MySqrtRec(in int x)
        {
            if (x < 2) return x;

            var left = MySqrtRec(x >> 2) << 1;

            var right = left + 1;
            return right * right > x ? left : right;
        }

        public double MyPow(double x, int n)
        {
            if (n < 0)
            {
                x = 1 / x;
                n = -n;
            }

            return MyPowRec(x, n);
        }

        private double MyPowRec(in double x, in int n)
        {
            if (n == 0) return 1;

            var half = MyPowRec(x, n / 2);

            if (n % 2 == 0) return half * half;

            else return half * half * x;
        }

        public int Divide3(int dividend, int divisor)
        {
            if (dividend == int.MinValue && divisor == -1) return int.MaxValue;
            int halfMin = -(int)Math.Pow(2, 30);
            int quotient = 0, negatives = 2;
            if (dividend > 0)
            {
                negatives--;
                dividend = -dividend;
            }
            if (divisor > 0)
            {
                negatives--;
                divisor = -divisor;
            }
            List<int> divisorsList = new List<int> { divisor }, doublesList = new List<int> { -1 };
            int tempDivisor = divisor, doubles = -1;
            // avoid Overflow (2 * 2^30 + 1)
            while (tempDivisor >= halfMin && dividend <= tempDivisor + tempDivisor)
            {
                tempDivisor += tempDivisor;
                doubles += doubles;
                doublesList.Add(doubles);
                divisorsList.Add(tempDivisor);
            }

            for (int i = divisorsList.Count - 1; i >= 0; i--)
            {
                if (divisorsList[i] >= dividend)
                {
                    quotient += doublesList[i];
                    dividend -= divisorsList[i];
                }
            }

            if (negatives != 1)
                quotient = -quotient;

            return quotient;
        }

        public int Divide_OLogSquareN(int dividend, int divisor)
        {
            if (dividend == int.MinValue && divisor == -1) return int.MaxValue;
            int halfMin = -(int)Math.Pow(2, 30);
            int quotient = 0, negatives = 2;
            if (dividend > 0)
            {
                negatives--;
                dividend = -dividend;
            }
            if (divisor > 0)
            {
                negatives--;
                divisor = -divisor;
            }
            while (dividend <= divisor)
            {
                int tempDivisor = divisor, doubles = -1;
                // avoid Overflow (2 * 2^30 + 1)
                while (tempDivisor >= halfMin && dividend <= tempDivisor + tempDivisor)
                {
                    tempDivisor += tempDivisor;
                    doubles += doubles;
                }

                quotient += doubles;
                dividend -= tempDivisor;
            }

            if (negatives != 1)
                quotient = -quotient;

            return quotient;
        }

        public int[] Intersect(int[] nums1, int[] nums2)
        {
            var dic = new Dictionary<int, int>();
            foreach (var i in nums1)
            {
                if (!dic.ContainsKey(i))
                    dic.Add(i, 0);
                dic[i]++;
            }

            var lst = new List<int>();
            foreach (var i in nums2)
            {
                if (dic.ContainsKey(i))
                {
                    lst.Add(i);
                    dic[i]--;
                    if (dic[i] == 0)
                    {
                        dic.Remove(i);
                    }
                }
            }

            return lst.ToArray();
        }

        public int[] Intersection(int[] nums1, int[] nums2)
        {
            var hs = nums1.ToHashSet();
            var lst = new HashSet<int>();
            foreach (var i in nums2)
            {
                if (hs.Contains(i))
                {
                    lst.Add(i);
                }
            }

            return lst.ToArray();
        }

        public class VersionControl
        {
            private bool[] arr = new[] { false, false, false, true, true };

            public int count = 0;
            public bool IsBadVersion(int version)
            {
                count++;
                return arr[version];
            }
        }

        public class Solution5 : VersionControl
        {
            public int FirstBadVersion(int n)
            {
                int low = 0, high = n - 1;

                while (low < high)
                {
                    int mid = low + (high - low) / 2;

                    var isBadVersion = this.IsBadVersion(mid + 1);
                    if (isBadVersion)
                        high = mid;
                    else low = mid + 1;
                }

                return low + 1;
            }
        }

        public int Search(int[] nums, int target)
        {
            int low = 0, high = nums.Length - 1;

            while (low <= high)
            {
                int mid = low + (high - low) / 2;

                if (nums[mid] == target) return mid;

                if (nums[low] <= nums[mid])
                {
                    if (target >= nums[low] && target < nums[mid])
                    {
                        high = mid - 1;
                    }
                    else low = mid + 1;
                }
                else
                {
                    if (target > nums[mid] && target <= nums[high])
                    {
                        low = mid + 1;
                    }
                    else high = mid - 1;
                }
            }

            return -1;
        }

        public int NumPairsDivisibleBy60(int[] time)
        {
            if (time == null || time.Length == 0) return 0;
            var modCount = new Dictionary<int, int>();

            int count = 0;
            for (int i = 0; i < time.Length; i++)
            {
                int mod = time[i] % 60, target = mod == 0 ? mod : 60 - mod;
                if (modCount.ContainsKey(target))
                {
                    count += modCount[target];
                }

                if (!modCount.ContainsKey(mod))
                    modCount.Add(mod, 0);
                modCount[mod]++;
            }

            return count;
        }

        public string ValidIPAddress(string IP)
        {
            if (string.IsNullOrEmpty(IP)) return "Neither";
            if (IP.Contains('.'))
                return ValidateIPV4Address(IP);
            return ValidateIPV6Address(IP);
        }

        private string ValidateIPV6Address(string ip)
        {
            string invalid = "Neither";
            char separator = ':';
            int left = 0, colonsCount = 0, portionsCount = 0, i;
            for (i = 0; i < ip.Length; i++)
            {
                if (!IsValidV6Char(ip[i]) || i - left > 4) return invalid;
                if (ip[i] == separator || i == ip.Length - 1)
                {
                    if (i != ip.Length - 1 && i == left) return invalid;
                    if (ip[i] == separator) colonsCount++;
                    if (colonsCount > 7) return invalid;
                    var portion = ip.Substring(left, i - left + (i == ip.Length - 1 && ip[i] != separator ? 1 : 0));
                    if (Convert.ToInt32(portion, 16) > 65535) return invalid;
                    left = i + 1;
                }
                if (i > 0 && ip[i - 1] == separator)
                    portionsCount++;
            }
            if (ip[i - 1] != separator)
                portionsCount++;

            return colonsCount == 7 && portionsCount == 8 ? "IPv6" : invalid;
        }

        private bool IsValidV6Char(char c)
        {
            if (char.IsDigit(c)) return true;
            if (('a' <= c && c <= 'f') || ('A' <= c && c <= 'F') || c == ':') return true;
            return false;
        }

        private string ValidateIPV4Address(string ip)
        {
            string invalid = "Neither";
            char separator = '.';
            int left = 0, dotsCount = 0, portionsCount = 0, i;
            for (i = 0; i < ip.Length; i++)
            {
                if ((ip[i] != separator && !char.IsDigit(ip[i])) || i - left > 3) return invalid;
                if (ip[i] == separator || i == ip.Length - 1)
                {
                    if (i != ip.Length - 1 && i == left) return invalid;
                    if (ip[i] == separator) dotsCount++;
                    if (dotsCount > 3) return invalid;
                    var portion = ip.Substring(left, i - left + (i == ip.Length - 1 && ip[i] != separator ? 1 : 0));
                    if (portion.Length > 1 && portion[0] == '0') return invalid;
                    if (int.Parse(portion) > 255) return invalid;
                    left = i + 1;
                }
                if (i > 0 && ip[i - 1] == separator)
                    portionsCount++;
            }
            if (ip[i - 1] != separator)
                portionsCount++;
            return dotsCount == 3 && portionsCount == 4 ? "IPv4" : invalid;
        }

        public class DisjointSet
        {
            public int[] parent, rank;

            public DisjointSet()
            {
                parent = new int[10001];
                rank = new int[10001];
            }

            public void Union(int i, int j)
            {
                var pi = Find(i);
                var pj = Find(j);

                if (pi == pj) return;

                if (rank[pi] >= rank[pj])
                {
                    rank[pi] += rank[pj];
                    rank[pj] = 0;
                    parent[pj] = pi;
                }
            }

            public int Find(in int x)
            {
                if (parent[x] != x) parent[x] = Find(parent[x]);

                return parent[x];
            }
        }

        public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts)
        {
            var ds = new DisjointSet();
            var emailToId = new Dictionary<string, int>();
            var emailToName = new Dictionary<string, string>();

            int idx = 0;
            foreach (var emails in accounts)
            {
                string name = string.Empty;
                foreach (var email in emails)
                {
                    if (name == string.Empty)
                    {
                        name = email;
                        continue;
                    }
                    ds.Union(GetOrAddId(ds, emailToId, email, ref idx), emailToId[emails[1]]);
                    if (!emailToName.ContainsKey(email))
                        emailToName.Add(email, name);
                }
            }

            var result = new List<IList<string>>();
            var dic = new Dictionary<int, List<string>>();
            foreach (var email in emailToId.Keys)
            {
                var p = ds.Find(emailToId[email]);
                if (!dic.ContainsKey(p))
                    dic.Add(p, new List<string>());
                dic[p].Add(email);
            }

            foreach (var lst in dic.Values)
            {
                lst.Sort(string.CompareOrdinal);
                lst.Insert(0, emailToName[lst[0]]);
                result.Add(lst);
            }

            return result;
        }

        private int GetOrAddId(DisjointSet ds, in Dictionary<string, int> emailToId, in string email, ref int idx)
        {
            if (!emailToId.ContainsKey(email))
            {
                emailToId.Add(email, idx++);
                ds.parent[idx - 1] = idx - 1;
            }

            return emailToId[email];
        }

        public class MountainArray
        {
            private int[] arr;

            public MountainArray(int[] arr)
            {
                this.arr = arr;
            }

            public int Get(int index)
            {
                return arr[index];
            }

            public int Length()
            {
                return arr.Length;
            }
        }

        public int FindInMountainArray(int target, MountainArray mountainArr)
        {
            int n = mountainArr.Length();
            int low = 0, high = n - 1;

            var dic = new Dictionary<int, int>();
            while (low < high)
            {
                int mid = low + (high - low) / 2;
                if (!dic.ContainsKey(mid))
                {
                    dic.Add(mid, mountainArr.Get(mid));
                }
                if (!dic.ContainsKey(mid + 1))
                {
                    dic.Add(mid + 1, mountainArr.Get(mid + 1));
                }
                if (dic[mid] > dic[mid + 1])
                {
                    high = mid;
                }
                else low = mid + 1;
            }

            int peak = low;

            if (target == dic[peak]) return peak;

            low = 0;
            high = peak;

            while (low < high)
            {
                int mid = low + (high - low) / 2;
                if (!dic.ContainsKey(mid))
                {
                    dic.Add(mid, mountainArr.Get(mid));
                }

                if (dic[mid] == target) return mid;
                else if (dic[mid] > target)
                {
                    high = mid;
                }
                else low = mid + 1;
            }


            low = peak;
            high = n - 1;

            while (low <= high)
            {
                int mid = low + (high - low) / 2;
                if (!dic.ContainsKey(mid))
                {
                    dic.Add(mid, mountainArr.Get(mid));
                }

                if (dic[mid] == target) return mid;
                else if (dic[mid] > target)
                {
                    low = mid + 1;
                }
                else high = mid - 1;
            }

            return -1;
        }

        public int PeakIndexInMountainArray(int[] arr)
        {
            int low = 0, high = arr.Length - 1;

            while (low < high)
            {
                int mid = low + (high - low) / 2;

                if (arr[mid] > arr[mid + 1])
                {
                    high = mid;
                }
                else low = mid + 1;
            }

            return low;
        }























        public int FindPeakElement(int[] nums)
        {
            int low = 0, high = nums.Length - 1;

            while (low < high)
            {
                int mid = low + (high - low) / 2;

                if (nums[mid] > nums[mid + 1])
                {
                    high = mid;
                }
                else
                {
                    low = mid + 1;
                }
            }

            return low;
        }


        public class NumMatrix1
        {
            private int[][] segArray;

            public NumMatrix1(int[][] matrix)
            {
                segArray = new int[matrix.Length][];

                int i = 0;
                foreach (var m in matrix)
                {
                    segArray[i] = new int[2 * m.Length];
                    BuildSegTree(m, segArray[i++]);
                }
            }

            private void BuildSegTree(int[] matrix, int[] seg)
            {
                for (int i = matrix.Length; i < seg.Length; i++)
                {
                    seg[i] = matrix[i - matrix.Length];
                }

                for (int i = matrix.Length - 1; i > 0; i--)
                {
                    seg[i] = seg[2 * i] + seg[2 * i + 1];
                }
            }

            public int SumRegion(int[] matrix, int i, int j)
            {
                int n = matrix.Length / 2;
                i += n;
                j += n;

                int sum = 0;
                while (i <= j)
                {
                    if (i % 2 == 1) sum += matrix[i++];
                    if (j % 2 == 0) sum += matrix[j--];

                    i /= 2;
                    j /= 2;
                }

                return sum;
            }

            public int SumRegion(int row1, int col1, int row2, int col2)
            {
                int sum = 0;

                for (int i = row1; i <= row2; i++)
                {
                    sum += SumRegion(segArray[i], col1, col2);
                }
                return sum;
            }
        }


        public IList<string> LetterCombinations(string digits)
        {
            if (string.IsNullOrEmpty(digits)) return new List<string>();

            var dic = new Dictionary<char, List<char>>
            {
                {'2', new List<char> {'a', 'b', 'c'}},
                {'3', new List<char> {'d', 'e', 'f'}},
                {'4', new List<char> {'g', 'h', 'i'}},
                {'5', new List<char> {'j', 'k', 'l'}},
                {'6', new List<char> {'m', 'n', 'o'}},
                {'7', new List<char> {'p', 'q', 'r', 's'}},
                {'8', new List<char> {'t', 'u', 'v'}},
                {'9', new List<char> {'w', 'x', 'y', 'z'}}
            };

            var list = new List<string>
            {
                ""
            };
            foreach (var digit in digits)
            {
                var tempList = new List<string>();
                var size = list.Count;
                for (int i = 0; i < list.Count; i++)
                {
                    foreach (var ch in dic[digit])
                        tempList.Add(list[i] + ch);
                }
                list = tempList;
            }

            return list;
        }

        public int SubarraySum(int[] nums, int k)
        {
            if (nums == null || nums.Length == 0) return 0;

            int sum = 0, count = 0;
            var dic = new Dictionary<int, int>
            {
                {0, 1}
            };
            for (int i = 0; i < nums.Length; i++)
            {
                sum += nums[i];

                if (dic.ContainsKey(sum - k))
                {
                    count += dic[sum - k];
                }

                if (dic.ContainsKey(sum))
                {
                    dic[sum]++;
                }
                else dic.Add(sum, 1);
            }

            return count;
        }

        public bool ValidPalindrome(string s)
        {
            if (string.IsNullOrEmpty(s)) return false;
            return ValidPalindromeRec(s, 0, s.Length - 1, true);
        }

        private bool ValidPalindromeRec(string s, int left, int right, bool canSkip)
        {
            if (left >= right) return true;
            if (s[left] == s[right])
                return ValidPalindromeRec(s, left + 1, right - 1, canSkip);

            if (canSkip)
            {
                return ValidPalindromeRec(s, left + 1, right, false)
                       || ValidPalindromeRec(s, left, right - 1, false);
            }
            return false;
        }

        public int MinimumEffort(int[][] tasks)
        {
            tasks = tasks.OrderByDescending(t => t[1] - t[0]).ToArray();

            var sum = 0;
            var whatWeHave = 0;
            for (int i = 0; i < tasks.Length; i++)
            {
                var task = tasks[i];

                if (whatWeHave < task[1])
                {
                    sum += (task[1] - whatWeHave);

                    whatWeHave = task[1];
                }

                whatWeHave -= task[0];
            }

            return sum;
        }

        public int WaysToMakeFair(int[] nums)
        {
            if (nums == null || nums.Length == 0) return 0;
            int[] oddLeft = new int[nums.Length],
                evenLeft = new int[nums.Length],
                oddRight = new int[nums.Length],
                evenRight = new int[nums.Length];

            evenLeft[0] = nums[0];
            for (int i = 1; i < nums.Length; i++)
            {
                oddLeft[i] = oddLeft[i - 1] + ((i % 2 == 1) ? nums[i] : 0);
                evenLeft[i] = evenLeft[i - 1] + ((i % 2 == 0) ? nums[i] : 0);
            }

            if (nums.Length % 2 == 0)
            {
                oddRight[nums.Length - 1] = nums[nums.Length - 1];
            }
            else
            {
                evenRight[nums.Length - 1] = nums[nums.Length - 1];
            }

            for (int i = nums.Length - 2; i >= 0; i--)
            {
                oddRight[i] = oddRight[i + 1] + ((i % 2 == 1) ? nums[i] : 0);
                evenRight[i] = evenRight[i + 1] + ((i % 2 == 0) ? nums[i] : 0);
            }

            int count = 0;
            for (int i = 0; i < nums.Length; i++)
            {
                if ((i - 1 >= 0 ? oddLeft[i - 1] : 0) + (i + 1 < nums.Length ? evenRight[i + 1] : 0) ==
                    (i - 1 >= 0 ? evenLeft[i - 1] : 0) + (i + 1 < nums.Length ? oddRight[i + 1] : 0)) count++;
            }

            return count;
        }

        public string GetSmallestString(int n, int k)
        {
            if (n < 1 || k < 1 || n > k) return string.Empty;
            var sb = new StringBuilder(new string('a', n));
            var sum = n;

            if (sum > k) return string.Empty;
            if (sum == k) return sb.ToString();

            for (int i = n - 1; i >= 0; i--)
            {
                if (k - sum == 0) break;

                var margin = (k - sum > 25 ? 25 : (k - sum));
                sb[i] = (char)(sb[i] + margin);
                sum += margin;
            }

            return k - sum == 0 ? sb.ToString() : string.Empty;
        }

        public bool ArrayStringsAreEqual(string[] word1, string[] word2)
        {
            return string.Join("", word1).Equals(string.Join("", word2));
        }

        public void MoveZeroes(int[] nums)
        {
            if (nums == null || nums.Length <= 1) return;
            int writeIndex = 0;
            for (int i = 0; i < nums.Length; i++)
            {
                if (nums[i] != 0) nums[writeIndex++] = nums[i];
            }

            while (writeIndex < nums.Length)
            {
                nums[writeIndex++] = 0;
            }
        }

        public int LongestValidParentheses(string s)
        {
            var st = new Stack<int>();
            st.Push(-1);

            int max = 0;
            for (int i = 0; i < s.Length; i++)
            {
                if (s[i] == '(') st.Push(i);
                else
                {
                    st.Pop();
                    if (st.Count == 0)
                    {
                        st.Push(i);
                    }
                    else
                    {
                        max = Math.Max(max, i - st.Peek());
                    }
                }
            }

            return max;
        }

        public int LongestValidParentheses1(string s)
        {
            if (string.IsNullOrEmpty(s)) return 0;

            var dp = new int[s.Length];
            int max = int.MinValue;
            for (int i = 1; i < s.Length; i++)
            {
                if (s[i] == ')')
                {
                    if (s[i - 1] == '(')
                    {
                        dp[i] = (i - 2 >= 0 ? dp[i - 2] : 0) + 2;
                    }
                    else if (i - dp[i - 1] - 1 >= 0 && s[i - dp[i - 1] - 1] == '(')
                    {
                        dp[i] = dp[i - 1] + (i - dp[i - 1] - 2 >= 0 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                    }

                    max = Math.Max(max, dp[i]);
                }
            }

            return max == int.MinValue ? 0 : max;
        }

        public void ReorderList(ListNode head)
        {
            if (head?.next == null) return;
            ListNode slow = head, fast = head.next;
            while (fast != null)
            {
                slow = slow.next;
                fast = fast.next?.next;
            }

            ListNode node = slow, prev = null;
            while (node != null)
            {
                var temp = node.next;
                node.next = prev;
                prev = node;
                node = temp;
            }

            ListNode first = head, second = prev;
            while (second.next != null)
            {
                var temp = first.next;
                first.next = second;
                first = temp;

                temp = second.next;
                second.next = first;
                second = temp;
            }
        }

        public ListNode ReverseBetween1(ListNode head, int m, int n)
        {
            if (head?.next == null || m == n) return head;

            ListNode start = head, end = head;
            while (n - m > 0)
            {
                end = end.next;
                n--;
            }

            ListNode prevStart = null;
            while (m > 1)
            {
                prevStart = start;
                end = end.next;
                start = start.next;
                m--;
            }

            ListNode node = start.next, prev = start;
            var isHeadAffected = prev == head;
            if (prevStart != null)
            {
                prevStart.next = end;
            }
            prev.next = end.next;
            var stop = end.next;
            while (node != stop)
            {
                var temp = node.next;
                node.next = prev;
                prev = node;
                node = temp;
            }
            return isHeadAffected ? prev : head;
        }

        public void reorderList(ListNode head)
        {
            if (head == null) return;
            reorderList(head, head.next);
        }

        public ListNode reorderList(ListNode root, ListNode curr)
        {
            if (curr == null) return root;

            // keep on passing the intial root to the end
            root = reorderList(root, curr.next);

            if (root == null) return null;
            /** 
             * we stop reconfiguring in 2 cases. 
             *   1. returned new root is same as head: Odd number of list items so we have come to the middle
             *   2. returned new root's next is same as head: Even number of list items
             **/
            ListNode temp = null;
            if (root == curr || root.next == curr)
            {
                curr.next = null;
            }
            else
            {
                // make returned root's next to be curr and return root's next as the new root
                temp = root.next;
                root.next = curr;
                curr.next = temp;
            }
            return temp;
        }

        public ListNode ReverseBetween(ListNode head, int m, int n)
        {
            if (head?.next == null) return head;
            int i = 1;
            ListNode left = head, prevLeft = null;
            while (i < m)
            {
                prevLeft = left;
                left = left.next;
                i++;
            }

            var right = left;
            while (i < n)
            {
                right = right.next;
                i++;
            }

            var prev = left;
            left = left.next;
            prev.next = right.next;
            if (prevLeft != null)
                prevLeft.next = right;
            var stop = right.next;
            while (left != null && left != stop)
            {
                var temp = left.next;
                left.next = prev;
                prev = left;
                left = temp;
            }

            return m == 1 ? prev : head;
        }

        public ListNode ReverseList(ListNode head)
        {
            if (head?.next == null) return head;
            ListNode prev = null, slow = head;
            while (slow != null)
            {
                var temp = slow.next;
                slow.next = prev;
                prev = slow;
                slow = temp;
            }
            return prev;
        }


        public IList<IList<int>> Subsets(int[] nums)
        {
            var res = new List<IList<int>>
            {
                new List<int>()
            };
            for (int i = 0; i < nums.Length; i++)
            {
                var lstCount = res.Count;
                for (int j = 0; j < lstCount; j++)
                {
                    var newOption = new List<int>(res[j]) { nums[i] };
                    res.Add(newOption);
                }
            }
            return res;
        }

        public IList<string> RemoveInvalidParentheses(string s)
        {
            var lst = new HashSet<string>();

            int toRemoveOpen = 0, toRemoveClose = 0;
            for (int i = 0; i < s.Length; i++)
            {
                if (s[i] == '(')
                    toRemoveOpen++;
                else if (s[i] == ')')
                {
                    if (toRemoveOpen > 0) toRemoveOpen--;
                    else toRemoveClose++;
                }
            }


            var sb = new StringBuilder();
            RemoveInvalidParenthesesRec(s, 0, toRemoveOpen, toRemoveClose, 0, 0, ref sb, ref lst);

            return lst.ToList();
        }

        private void RemoveInvalidParenthesesRec(string s, int i, int toRemoveOpen, int toRemoveClose, int openCount, int closeCount, ref StringBuilder sb, ref HashSet<string> lst)
        {
            if (i == s.Length)
            {
                if (toRemoveOpen == 0 && toRemoveClose == 0)
                {
                    lst.Add(sb.ToString());
                }
                return;
            }

            var ch = s[i];
            if ((ch == '(' && toRemoveOpen > 0) || (ch == ')' && toRemoveClose > 0))
            {
                RemoveInvalidParenthesesRec(s, i + 1, toRemoveOpen - (ch == '(' ? 1 : 0),
                    toRemoveClose - (ch == ')' ? 1 : 0), openCount, closeCount, ref sb, ref lst);
            }

            sb.Append(ch);
            if (ch == '(' || ch == ')')
            {
                if (ch == '(')
                {
                    RemoveInvalidParenthesesRec(s, i + 1, toRemoveOpen, toRemoveClose, openCount + 1, closeCount,
                        ref sb, ref lst);
                }
                else if (openCount > closeCount)
                {
                    RemoveInvalidParenthesesRec(s, i + 1, toRemoveOpen, toRemoveClose, openCount, closeCount + 1,
                        ref sb, ref lst);
                }
            }
            else
            {
                RemoveInvalidParenthesesRec(s, i + 1, toRemoveOpen, toRemoveClose, openCount, closeCount, ref sb, ref lst);
            }
            sb.Length--;
        }


        public IList<IList<int>> PermuteUnique(int[] nums)
        {
            var lst = new List<IList<int>>();
            if (nums == null || nums.Length == 0) return lst;
            var counts = new Dictionary<int, int>();
            for (int i = 0; i < nums.Length; i++)
            {
                if (counts.ContainsKey(nums[i]))
                    counts[nums[i]]++;
                else counts.Add(nums[i], 1);
            }
            PermuteUniqueRec(counts, new List<int>(), ref lst, nums.Length);
            return lst;
        }

        private void PermuteUniqueRec(Dictionary<int, int> counts, List<int> option, ref List<IList<int>> lst, in int n)
        {
            if (option.Count == n)
            {
                lst.Add(new List<int>(option));
                return;
            }

            for (int i = 0; i < counts.Count; i++)
            {
                var pair = counts.ElementAt(i);
                if (pair.Value == 0) continue;
                option.Add(pair.Key);
                counts[pair.Key]--;

                PermuteUniqueRec(counts, option, ref lst, n);

                option.RemoveAt(option.Count - 1);
                counts[pair.Key]++;
            }
        }


        public IList<IList<int>> Permute(int[] nums)
        {
            var lst = new List<IList<int>>();
            if (nums == null || nums.Length == 0) return lst;
            PermuteRec(nums, 0, nums.Length - 1, ref lst);
            return lst;
        }

        private void PermuteRec(int[] nums, int left, in int right, ref List<IList<int>> lst)
        {
            if (left >= right)
            {
                lst.Add(new List<int>(nums));
                return;
            }

            for (int i = left; i <= right; i++)
            {
                Swap(nums, i, left);

                PermuteRec(nums, left + 1, right, ref lst);

                Swap(nums, i, left);
            }
        }

        public IList<int> FindAnagrams(string s, string p)
        {
            var res = new List<int>();
            if (string.IsNullOrEmpty(s) || string.IsNullOrEmpty(p) || p.Length > s.Length) return res;

            int[] sFreq = new int[26], pFreq = new int[26];
            int left = 0, right;
            for (right = 0; right < p.Length; right++)
            {
                pFreq[p[right] - 'a']++;
                sFreq[s[right] - 'a']++;
            }

            if (IsEqualArray(pFreq, sFreq)) res.Add(left);
            while (right < s.Length)
            {
                sFreq[s[left++] - 'a']--;
                sFreq[s[right++] - 'a']++;
                if (IsEqualArray(pFreq, sFreq)) res.Add(left);
            }

            return res;
        }

        public bool CheckInclusion(string s1, string s2)
        {
            if (string.IsNullOrEmpty(s1) || string.IsNullOrEmpty(s2) || s1.Length > s2.Length) return false;
            int[] s1Freq = new int[26], s2Freq = new int[26];
            for (int i = 0; i < s1.Length; i++)
            {
                s1Freq[s1[i] - 'a']++;
                s2Freq[s2[i] - 'a']++;
            }

            if (IsEqualArray(s1Freq, s2Freq)) return true;
            int left = 0, right = s1.Length - 1;
            while (right < s2.Length - 1)
            {
                s2Freq[s2[left++] - 'a']--;
                s2Freq[s2[++right] - 'a']++;
                if (IsEqualArray(s1Freq, s2Freq)) return true;
            }

            return false;
        }

        private bool IsEqualArray(int[] a, int[] b)
        {
            if (a.Length != b.Length) return false;
            for (int i = 0; i < a.Length; i++)
            {
                if (a[i] != b[i]) return false;
            }
            return true;
        }

        //public string AddBinary(string a, string b)
        //{

        //}

        public string AddBinary1(string a, string b)
        {
            if (string.IsNullOrEmpty(a) || string.IsNullOrEmpty(b)) return "";
            int maxLength = Math.Max(a.Length, b.Length);
            var sb = new StringBuilder(maxLength + 1);

            int carry = 0;
            for (int i = a.Length - 1, j = b.Length - 1; i >= 0 || j >= 0; i--, j--)
            {
                var sum = carry + (i >= 0 ? (a[i] - 48) : 0) + (j >= 0 ? (b[j] - 48) : 0);
                carry = sum / 2;
                sb.Append(sum % 2);
            }

            if (carry > 0) sb.Append(carry);

            return new string(sb.ToString().Reverse().ToArray());
        }

        public class ArrayComparer : IEqualityComparer<int[]>
        {
            public bool Equals(int[] x, int[] y)
            {
                if (x == null || y == null || x.Length != y.Length) return false;
                for (int i = 0; i < x.Length; i++)
                {
                    if (x[i] != y[i]) return false;
                }
                return true;
            }

            public int GetHashCode(int[] array)
            {
                int hc = array.Length;
                for (int i = 0; i < array.Length; ++i)
                {
                    hc = unchecked(hc * 314159 + array[i]);
                }
                return hc;
            }
        }

        public IList<IList<string>> GroupAnagrams(string[] strs)
        {
            var dic = new Dictionary<int[], List<string>>(new ArrayComparer());
            foreach (var str in strs)
            {
                var hash = new int[26];
                for (int i = 0; i < str.Length; i++)
                {
                    hash[str[i] - 'a']++;
                }

                if (dic.ContainsKey(hash))
                {
                    dic[hash].Add(str);
                }
                else
                {
                    dic.Add(hash, new List<string> { str });
                }
            }

            var result = new List<IList<string>>();
            foreach (var list in dic.Values)
            {
                result.Add(list);
            }

            return result;
        }

        public int RemoveDuplicates(int[] nums)
        {
            if (nums == null || nums.Length <= 1) return 0;

            int writeIndx = 1;
            for (int i = 1; i < nums.Length; i++)
            {
                if (nums[i] != nums[i - 1])
                {
                    nums[writeIndx++] = nums[i];
                }
            }

            return writeIndx;
        }

        public int DiameterOfBinaryTree(TreeNode root)
        {
            if (root == null) return 0;
            int max = int.MinValue;
            DiameterOfBinaryTreeRec(root, ref max);
            return max;
        }

        private int DiameterOfBinaryTreeRec(TreeNode node, ref int max)
        {
            if (node == null) return 0;

            var leftPath = DiameterOfBinaryTreeRec(node.left, ref max);
            var rightPath = DiameterOfBinaryTreeRec(node.right, ref max);

            max = Math.Max(max, leftPath + rightPath);

            return Math.Max(leftPath, rightPath) + 1;
        }

        public int ShortestDistance(int[][] grid)
        {
            if (grid == null || grid.Length == 0 || grid[0].Length == 0) return -1;
            int[,] distance = new int[grid.Length, grid[0].Length], reach = new int[grid.Length, grid[0].Length];
            int[] rowsMoves = new[] { 0, 0, -1, 1 }, colsMoves = new[] { -1, 1, 0, 0 };
            int buildingsCount = 0;
            for (int i = 0; i < grid.Length; i++)
            {
                for (int j = 0; j < grid[i].Length; j++)
                {
                    if (grid[i][j] == 1)
                    {
                        int level = 1;
                        buildingsCount++;
                        var visited = new bool[grid.Length, grid[0].Length];
                        var q = new Queue<(int x, int y)>();
                        q.Enqueue((i, j));
                        q.Enqueue((-1, -1));
                        while (q.Count > 0)
                        {
                            var (x, y) = q.Dequeue();
                            if (x == -1 && y == -1)
                            {
                                if (q.Count > 0)
                                {
                                    level++;
                                    q.Enqueue((-1, -1));
                                }
                                continue;
                            }

                            visited[x, y] = true;
                            for (int k = 0; k < rowsMoves.Length; k++)
                            {
                                int newX = x + rowsMoves[k], newY = y + colsMoves[k];
                                if (newX >= 0 && newX < grid.Length && newY >= 0 && newY < grid[x].Length &&
                                    !visited[newX, newY] && grid[newX][newY] == 0)
                                {
                                    visited[newX, newY] = true;
                                    distance[newX, newY] += level;
                                    reach[newX, newY]++;
                                    q.Enqueue((newX, newY));
                                }
                            }
                        }
                    }
                }
            }

            int minDistance = int.MaxValue;
            for (int i = 0; i < grid.Length; i++)
            {
                for (int j = 0; j < grid[i].Length; j++)
                {
                    if (grid[i][j] == 0 && reach[i, j] == buildingsCount)
                    {
                        minDistance = Math.Min(minDistance, distance[i, j]);
                    }
                }
            }

            return minDistance == int.MaxValue ? -1 : minDistance;
        }

        public int NextGreaterElement(int n)
        {
            var num = n.ToString().ToCharArray();

            if (num.Length < 2) return -1;

            int i, j;
            for (i = num.Length - 2; i >= 0; i--)
            {
                if (num[i] < num[i + 1]) break;
            }

            if (i < 0) return -1;

            for (j = num.Length - 1; j >= 0; j--)
            {
                if (num[j] > num[i]) break;
            }

            Swap(num, i, j);

            i++;
            j = num.Length - 1;
            while (i < j)
            {
                Swap(num, i++, j--);
            }

            return int.TryParse(new string(num), out var x) ? x : -1;
        }

        public IList<string> BinaryTreePaths(TreeNode root)
        {
            var paths = new List<string>();
            if (root == null) return paths;

            var path = new List<int>();
            BuildPaths(root, ref path, ref paths);

            return paths;
        }

        private void BuildPaths(TreeNode node, ref List<int> path, ref List<string> paths)
        {
            if (node == null)
                return;

            path.Add(node.val);

            if (node.left == null && node.right == null)
                paths.Add(string.Join("->", path));

            if (node.left != null) BuildPaths(node.left, ref path, ref paths);
            if (node.right != null) BuildPaths(node.right, ref path, ref paths);

            path.RemoveAt(path.Count - 1);
        }

        public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)
        {
            if (root == null || p == null || q == null) return null;
            List<TreeNode> pPath = new List<TreeNode>(), qPath = new List<TreeNode>();
            FindNode(root, p, ref pPath);
            FindNode(root, q, ref qPath);

            var minPathLength = Math.Min(pPath.Count, qPath.Count);
            var lowestAncestor = root;
            for (int i = 0; i < minPathLength; i++)
            {
                if (pPath[i] == qPath[i]) lowestAncestor = pPath[i];
                else break;
            }

            return lowestAncestor;
        }

        private bool FindNode(TreeNode node, TreeNode target, ref List<TreeNode> path)
        {
            path.Add(node);
            if (node.val == target.val) return true;

            if (node.left != null)
            {
                if (FindNode(node.left, target, ref path)) return true;
            }

            if (node.right != null)
            {
                if (FindNode(node.right, target, ref path)) return true;
            }

            path.RemoveAt(path.Count - 1);

            return false;
        }

        public class DSUIslands
        {
            public int componentsCount;
            public int[] parents;
            public int[] sizes;

            public DSUIslands(char[][] grid)
            {
                int rows = grid.Length, cols = grid[0].Length;
                componentsCount = 0;
                parents = new int[rows * cols];
                sizes = new int[rows * cols];
                for (int i = 0; i < grid.Length; i++)
                {
                    for (int j = 0; j < grid[i].Length; j++)
                    {
                        if (grid[i][j] == '1')
                        {
                            componentsCount++;
                            parents[i * cols + j] = i * cols + j;
                        }
                        sizes[i * cols + j] = 0;
                    }
                }
            }

            public bool Union(int i, int j)
            {
                var p1 = GetParent(i);
                var p2 = GetParent(j);

                if (p1 == p2) return false;
                if (sizes[p1] >= sizes[p2])
                {
                    parents[p2] = p1;
                    parents[j] = p1;
                    sizes[p1] += sizes[p2];
                    sizes[p2] = 0;
                }
                else
                {
                    parents[p1] = p2;
                    parents[i] = p2;
                    sizes[p2] += sizes[p1];
                    sizes[p1] = 0;
                }

                componentsCount--;
                return true;
            }

            public int GetParent(in int p)
            {
                if (parents[p] != p) parents[p] = GetParent(parents[p]);
                return parents[p];
            }
        }

        public int NumIslands(char[][] grid)
        {
            if (grid == null || grid.Length == 0 || grid[0].Length == 0) return 0;

            var dsu = new DSUIslands(grid);
            var directions = new int[][]
            {
                new[] {0, -1},
                new[] {0, 1},
                new[] {-1, 0},
                new[] {1, 0}
            };
            for (int i = 0; i < grid.Length; i++)
            {
                for (int j = 0; j < grid[i].Length; j++)
                {
                    if (grid[i][j] == '1')
                    {
                        grid[i][j] = '0';
                        foreach (var direction in directions)
                        {
                            int newX = i + direction[0], newY = j + direction[1];
                            if (newX >= 0 && newX < grid.Length && newY >= 0 && newY < grid[i].Length &&
                                grid[newX][newY] == '1')
                            {
                                dsu.Union(i * grid[i].Length + j, newX * grid[i].Length + newY);
                            }
                        }
                    }
                }
            }

            return dsu.componentsCount;
        }

        public int NumIslands1(char[][] grid)
        {
            if (grid == null || grid.Length == 0 || grid[0].Length == 0) return 0;

            int islandsCount = 0;
            var directions = new int[][]
            {
                new[] {0, -1},
                new[] {0, 1},
                new[] {-1, 0},
                new[] {1, 0}
            };
            for (int i = 0; i < grid.Length; i++)
            {
                for (int j = 0; j < grid[i].Length; j++)
                {
                    if (grid[i][j] == '1')
                    {
                        islandsCount++;
                        grid[i][j] = '0';
                        var q = new Queue<(int x, int y)>();
                        q.Enqueue((i, j));
                        while (q.Count > 0)
                        {
                            var pos = q.Dequeue();
                            foreach (var direction in directions)
                            {
                                int newX = pos.x + direction[0], newY = pos.y + direction[1];
                                if (newX >= 0 && newX < grid.Length && newY >= 0 && newY < grid[pos.x].Length &&
                                    grid[newX][newY] == '1')
                                {
                                    grid[newX][newY] = '0';
                                    q.Enqueue((newX, newY));
                                }
                            }
                        }
                    }
                }
            }

            return islandsCount;
        }

        public class TNode
        {
            public int val;
            public TNode left;
            public TNode right;
            public TNode random;

            public TNode(int val = 0, TNode left = null, TNode right = null, TNode random = null)
            {
                this.val = val;
                this.left = left;
                this.right = right;
                this.random = random;
            }
        }

        public class NodeCopy
        {
            public int val;
            public NodeCopy left;
            public NodeCopy right;
            public NodeCopy random;

            public NodeCopy(int val = 0, NodeCopy left = null, NodeCopy right = null, NodeCopy random = null)
            {
                this.val = val;
                this.left = left;
                this.right = right;
                this.random = random;
            }
        }

        public IList<int> RightSideView(TreeNode root)
        {
            var rightSideViewList = new List<int>();
            if (root == null) return rightSideViewList;
            var q = new Queue<TreeNode>();
            q.Enqueue(root);
            q.Enqueue(null);

            while (q.Count > 0)
            {
                var node = q.Dequeue();
                if (node == null)
                {
                    if (q.Count > 0) q.Enqueue(null);
                    continue;
                }

                if (q.Peek() == null)
                {
                    rightSideViewList.Add(node.val);
                }

                if (node.left != null) q.Enqueue(node.left);
                if (node.right != null) q.Enqueue(node.right);
            }

            return rightSideViewList;
        }

        public NodeCopy CopyRandomBinaryTree(TNode root)
        {
            var dic = new Dictionary<TNode, NodeCopy>();
            return CopyRandomBinaryTreeRec(root, dic);
        }

        private NodeCopy CopyRandomBinaryTreeRec(TNode node, Dictionary<TNode, NodeCopy> dic)
        {
            if (node == null) return null;

            if (dic.ContainsKey(node))
                return dic[node];

            var clonedNode = new NodeCopy(node.val);
            dic.Add(node, clonedNode);
            clonedNode.left = CopyRandomBinaryTreeRec(node.left, dic);
            clonedNode.right = CopyRandomBinaryTreeRec(node.right, dic);
            clonedNode.random = CopyRandomBinaryTreeRec(node.random, dic);

            return clonedNode;
        }

        //private NodeCopy CopyRandomBinaryTreeRec(TNode node, Dictionary<TNode, NodeCopy> dic)
        //{
        //    if (node == null) return null;

        //    if (!dic.ContainsKey(node)) dic.Add(node, new NodeCopy(node.val));
        //    var clonedNode = dic[node];
        //    if (node.random != null)
        //    {
        //        if (!dic.ContainsKey(node.random))
        //            dic.Add(node.random, new NodeCopy(node.random.val));
        //        clonedNode.random = dic[node.random];
        //    }
        //    var left = CopyRandomBinaryTreeRec(node.left, dic);
        //    var right = CopyRandomBinaryTreeRec(node.right, dic);

        //    clonedNode.left = left;
        //    clonedNode.right = right;

        //    return clonedNode;
        //}

        public GraphNode CloneGraph(GraphNode node)
        {
            if (node == null) return null;

            GraphNode newRoot = new GraphNode(node.val);
            var oldToNewMap = new Dictionary<GraphNode, GraphNode> { { node, newRoot } };
            var q = new Queue<GraphNode>();
            q.Enqueue(node);

            while (q.Count > 0)
            {
                var n = q.Dequeue();
                var newNode = oldToNewMap[n];
                foreach (var neighbor in n.neighbors)
                {
                    if (!oldToNewMap.ContainsKey(neighbor))
                    {
                        oldToNewMap.Add(neighbor, new GraphNode(neighbor.val));
                        q.Enqueue(neighbor);
                    }
                    newNode.neighbors.Add(oldToNewMap[neighbor]);
                }
            }

            return newRoot;
        }

        public int MaxPathSum(TreeNode root)
        {
            int max = int.MinValue;
            MaxPathSumRec(root, ref max);
            return max;
        }

        private int MaxPathSumRec(TreeNode node, ref int max)
        {
            if (node == null) return 0;

            var leftPath = MaxPathSumRec(node.left, ref max);
            var rightPath = MaxPathSumRec(node.right, ref max);

            var sum = Math.Max(leftPath, 0) + Math.Max(rightPath, 0) + node.val;
            max = Math.Max(max, sum);

            return node.val + Math.Max(Math.Max(leftPath, 0), Math.Max(rightPath, 0));
        }

        public void Flatten(TreeNode root)
        {
            FlattenRec(root);
        }

        private TreeNode FlattenRec(TreeNode node)
        {
            if (node == null) return null;

            var farLeft = FlattenRec(node.left);
            var farRight = FlattenRec(node.right);

            if (node.left != null)
            {
                var temp = node.right;
                node.right = node.left;
                farLeft.right = temp;
                node.left = null;
                return farRight ?? farLeft;
            }

            return farRight ?? node;
        }

        public bool IsValidBST1(TreeNode root)
        {
            return IsValidBSTRec(root, null, null);
        }

        private bool IsValidBSTRec(TreeNode node, in int? minValue, in int? maxValue)
        {
            if (node == null) return true;

            if ((minValue.HasValue && node.val <= minValue) || (maxValue.HasValue && node.val >= maxValue)) return false;

            return IsValidBSTRec(node.left, minValue, node.val) && IsValidBSTRec(node.right, node.val, maxValue);
        }

        public class NumMatrix
        {
            private int[][] segArr;

            public NumMatrix(int[][] matrix)
            {
                segArr = new int[matrix.Length][];
                for (int k = 0; k < matrix.Length; k++)
                {
                    var nums = matrix[k];
                    segArr[k] = new int[nums.Length * 2];

                    for (int i = segArr[k].Length - 1, j = nums.Length - 1; i >= nums.Length; i--, j--)
                        segArr[k][i] = nums[j];

                    for (int i = nums.Length - 1; i > 0; i--)
                        segArr[k][i] = segArr[k][2 * i] + segArr[k][2 * i + 1];
                }
            }

            public void Update(int row, int col, int val)
            {
                Update(segArr[row], col, val);
            }

            public int SumRegion(int row1, int col1, int row2, int col2)
            {
                var sum = 0;
                for (int i = row1; i <= row2; i++)
                {
                    sum += SumRange(segArr[i], col1, col2);
                }
                return sum;
            }


            public void Update(int[] arr, int i, int val)
            {
                i += (arr.Length / 2);
                arr[i] = val;
                while (i > 0)
                {
                    int left = i, right = i;
                    if (i % 2 == 0)
                        right = i + 1;
                    else
                        left = i - 1;
                    arr[i / 2] = arr[left] + arr[right];
                    i /= 2;
                }
            }

            public int SumRange(int[] arr, int i, int j)
            {
                int sum = 0;
                i += (arr.Length / 2);
                j += (arr.Length / 2);
                while (i <= j)
                {
                    if (i % 2 == 1)
                        sum += arr[i++];
                    if (j % 2 == 0)
                        sum += arr[j--];
                    i /= 2;
                    j /= 2;
                }
                return sum;
            }
        }

        public class NumArray
        {
            private int[] segArr;

            public NumArray(int[] nums)
            {
                segArr = new int[nums.Length * 2];

                for (int i = segArr.Length - 1, j = nums.Length - 1; i >= nums.Length; i--, j--)
                {
                    segArr[i] = nums[j];
                }

                for (int i = nums.Length - 1; i > 0; i--)
                {
                    segArr[i] = segArr[2 * i] + segArr[2 * i + 1];
                }
            }

            public void Update(int i, int val)
            {
                i += (segArr.Length / 2);

                segArr[i] = val;

                while (i > 0)
                {
                    int left = i, right = i;
                    if (i % 2 == 0)
                    {
                        right = i + 1;
                    }
                    else
                    {
                        left = i - 1;
                    }
                    segArr[i / 2] = segArr[left] + segArr[right];
                    i /= 2;
                }
            }

            public int SumRange(int i, int j)
            {
                int sum = 0;
                i += (segArr.Length / 2);
                j += (segArr.Length / 2);

                while (i <= j)
                {
                    if (i % 2 == 1)
                    {
                        sum += segArr[i++];
                    }

                    if (j % 2 == 0)
                    {
                        sum += segArr[j--];
                    }

                    i /= 2;
                    j /= 2;
                }

                return sum;
            }
        }


        public void NextPermutation(int[] nums)
        {
            int i, j;
            for (i = nums.Length - 2; i >= 0; i--)
                if (nums[i] < nums[i + 1]) break;
            if (i >= 0)
            {
                j = nums.Length - 1;
                while (j > i && nums[j] <= nums[i])
                    j--;
                Swap(nums, i, j);
            }

            j = nums.Length - 1;
            int k = i + 1;
            while (k < j)
            {
                Swap(nums, j, k);
                k++; j--;
            }
        }

        private void Swap<T>(T[] nums, in int i, in int j)
        {
            var temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }

        public IList<IList<int>> Permute1(int[] nums)
        {
            var lst = new List<IList<int>>();

            PermuteRec1(ref nums, 0, ref lst);

            return lst;
        }

        private void PermuteRec1(ref int[] nums, int i, ref List<IList<int>> lst)
        {
            if (i == nums.Length)
            {
                lst.Add(new List<int>(nums));
                return;
            }

            for (int j = i; j < nums.Length; j++)
            {
                var temp = nums[j];
                nums[j] = nums[i];
                nums[i] = temp;

                PermuteRec1(ref nums, i + 1, ref lst);

                temp = nums[j];
                nums[j] = nums[i];
                nums[i] = temp;
            }
        }

        public int MinAddToMakeValid(string S)
        {
            if (string.IsNullOrWhiteSpace(S)) return 0;

            int ans = 0, balance = 0;

            for (int i = 0; i < S.Length; i++)
            {
                balance += (S[i] == '(') ? 1 : -1;

                if (balance == -1)
                {
                    ans++;
                    balance++;
                }
            }

            return balance + ans;
        }

        public int SumSubarrayMins(int[] A)
        {
            int mod = 1_000_000_007;
            Stack<int> prevMinStack = new Stack<int>(), nextMinStack = new Stack<int>();
            int[] prev = new int[A.Length], next = new int[A.Length];

            for (int i = 0; i < A.Length; i++)
            {
                // prev[i] = i + 1 (means i is the lowest value to its lefts so it will be included in all sub arrays from 0 to i)
                prev[i] = i + 1;
                // next[i] = A.Length - i (means i is the lowest value to its rights so it will be included in all sub arrays from 0 to i)
                next[i] = A.Length - i;
            }

            for (int i = 0; i < A.Length; i++)
            {
                while (prevMinStack.Count > 0 && A[i] < A[prevMinStack.Peek()])
                {
                    prevMinStack.Pop();
                }
                prev[i] = prevMinStack.Count > 0 ? (i - prevMinStack.Peek()) : (i + 1);

                while (nextMinStack.Count > 0 && A[nextMinStack.Peek()] > A[i])
                {
                    next[nextMinStack.Peek()] = i - nextMinStack.Pop();
                }

                prevMinStack.Push(i);
                nextMinStack.Push(i);
            }

            int sum = 0;
            for (int i = 0; i < A.Length; i++)
            {
                sum += (next[i] * prev[i]) % mod * A[i] % mod;
            }

            return sum;
        }

        public int[] NextGreaterElement(int[] nums1, int[] nums2)
        {
            if (nums1 == null || nums1.Length == 0 || nums2 == null || nums2.Length == 0) return new int[0];
            var idxDic = new Dictionary<int, int>();
            var ngeSt = new Stack<int>();
            for (int i = 0; i < nums2.Length; i++)
            {
                while (ngeSt.Count > 0 && ngeSt.Peek() < nums2[i])
                {
                    idxDic.Add(ngeSt.Pop(), nums2[i]);
                }
                ngeSt.Push(nums2[i]);
            }

            while (ngeSt.Count > 0)
            {
                idxDic.Add(ngeSt.Pop(), -1);
            }

            var result = new int[nums1.Length];
            for (int i = 0; i < nums1.Length; i++)
            {
                result[i] = idxDic[nums1[i]];
            }

            return result;
        }
    }
}